
C:\Users\gcristian\Desktop\F429\Drivers\obj\stm32f4xx_rtc.o:     file format elf32-littlearm
C:\Users\gcristian\Desktop\F429\Drivers\obj\stm32f4xx_rtc.o


Disassembly of section .text.RTC_DeInit:

00000000 <RTC_DeInit>:
RTC_DeInit():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:376
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC registers are deinitialized
  *          - ERROR: RTC registers are not deinitialized
  */
ErrorStatus RTC_DeInit(void)
{
   0:	b580      	push	{r7, lr}
   2:	b084      	sub	sp, #16
   4:	af00      	add	r7, sp, #0
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:377
  __IO uint32_t wutcounter = 0x00;
   6:	f04f 0300 	mov.w	r3, #0
   a:	607b      	str	r3, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:378
  uint32_t wutwfstatus = 0x00;
   c:	f04f 0300 	mov.w	r3, #0
  10:	60bb      	str	r3, [r7, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:379
  ErrorStatus status = ERROR;
  12:	f04f 0300 	mov.w	r3, #0
  16:	73fb      	strb	r3, [r7, #15]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:382
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  18:	4b3f      	ldr	r3, [pc, #252]	; (118 <RTC_DeInit+0x118>)
  1a:	f04f 02ca 	mov.w	r2, #202	; 0xca
  1e:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:383
  RTC->WPR = 0x53;
  20:	4b3d      	ldr	r3, [pc, #244]	; (118 <RTC_DeInit+0x118>)
  22:	f04f 0253 	mov.w	r2, #83	; 0x53
  26:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:386

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
  28:	f7ff fffe 	bl	0 <RTC_DeInit>
  2c:	4603      	mov	r3, r0
  2e:	2b00      	cmp	r3, #0
  30:	d103      	bne.n	3a <RTC_DeInit+0x3a>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:388
  {
    status = ERROR;
  32:	f04f 0300 	mov.w	r3, #0
  36:	73fb      	strb	r3, [r7, #15]
  38:	e064      	b.n	104 <RTC_DeInit+0x104>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:393
  }  
  else
  {
    /* Reset TR, DR and CR registers */
    RTC->TR = (uint32_t)0x00000000;
  3a:	4b37      	ldr	r3, [pc, #220]	; (118 <RTC_DeInit+0x118>)
  3c:	f04f 0200 	mov.w	r2, #0
  40:	601a      	str	r2, [r3, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:394
    RTC->DR = (uint32_t)0x00002101;
  42:	4b35      	ldr	r3, [pc, #212]	; (118 <RTC_DeInit+0x118>)
  44:	f242 1201 	movw	r2, #8449	; 0x2101
  48:	605a      	str	r2, [r3, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:396
    /* Reset All CR bits except CR[2:0] */
    RTC->CR &= (uint32_t)0x00000007;
  4a:	4b33      	ldr	r3, [pc, #204]	; (118 <RTC_DeInit+0x118>)
  4c:	4a32      	ldr	r2, [pc, #200]	; (118 <RTC_DeInit+0x118>)
  4e:	6892      	ldr	r2, [r2, #8]
  50:	f002 0207 	and.w	r2, r2, #7
  54:	609a      	str	r2, [r3, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:401
  
    /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
    do
    {
      wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
  56:	4b30      	ldr	r3, [pc, #192]	; (118 <RTC_DeInit+0x118>)
  58:	68db      	ldr	r3, [r3, #12]
  5a:	f003 0304 	and.w	r3, r3, #4
  5e:	60bb      	str	r3, [r7, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:402
      wutcounter++;  
  60:	687b      	ldr	r3, [r7, #4]
  62:	f103 0301 	add.w	r3, r3, #1
  66:	607b      	str	r3, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:403
    } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
  68:	687b      	ldr	r3, [r7, #4]
  6a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
  6e:	d002      	beq.n	76 <RTC_DeInit+0x76>
  70:	68bb      	ldr	r3, [r7, #8]
  72:	2b00      	cmp	r3, #0
  74:	d0ef      	beq.n	56 <RTC_DeInit+0x56>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:405
    
    if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
  76:	4b28      	ldr	r3, [pc, #160]	; (118 <RTC_DeInit+0x118>)
  78:	68db      	ldr	r3, [r3, #12]
  7a:	f003 0304 	and.w	r3, r3, #4
  7e:	2b00      	cmp	r3, #0
  80:	d103      	bne.n	8a <RTC_DeInit+0x8a>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:407
    {
      status = ERROR;
  82:	f04f 0300 	mov.w	r3, #0
  86:	73fb      	strb	r3, [r7, #15]
  88:	e03c      	b.n	104 <RTC_DeInit+0x104>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:412
    }
    else
    {
      /* Reset all RTC CR register bits */
      RTC->CR &= (uint32_t)0x00000000;
  8a:	4b23      	ldr	r3, [pc, #140]	; (118 <RTC_DeInit+0x118>)
  8c:	689b      	ldr	r3, [r3, #8]
  8e:	4b22      	ldr	r3, [pc, #136]	; (118 <RTC_DeInit+0x118>)
  90:	f04f 0200 	mov.w	r2, #0
  94:	609a      	str	r2, [r3, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:413
      RTC->WUTR = (uint32_t)0x0000FFFF;
  96:	4b20      	ldr	r3, [pc, #128]	; (118 <RTC_DeInit+0x118>)
  98:	f64f 72ff 	movw	r2, #65535	; 0xffff
  9c:	615a      	str	r2, [r3, #20]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:414
      RTC->PRER = (uint32_t)0x007F00FF;
  9e:	4b1e      	ldr	r3, [pc, #120]	; (118 <RTC_DeInit+0x118>)
  a0:	4a1e      	ldr	r2, [pc, #120]	; (11c <RTC_DeInit+0x11c>)
  a2:	611a      	str	r2, [r3, #16]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:415
      RTC->CALIBR = (uint32_t)0x00000000;
  a4:	4b1c      	ldr	r3, [pc, #112]	; (118 <RTC_DeInit+0x118>)
  a6:	f04f 0200 	mov.w	r2, #0
  aa:	619a      	str	r2, [r3, #24]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:416
      RTC->ALRMAR = (uint32_t)0x00000000;        
  ac:	4b1a      	ldr	r3, [pc, #104]	; (118 <RTC_DeInit+0x118>)
  ae:	f04f 0200 	mov.w	r2, #0
  b2:	61da      	str	r2, [r3, #28]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:417
      RTC->ALRMBR = (uint32_t)0x00000000;
  b4:	4b18      	ldr	r3, [pc, #96]	; (118 <RTC_DeInit+0x118>)
  b6:	f04f 0200 	mov.w	r2, #0
  ba:	621a      	str	r2, [r3, #32]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:418
      RTC->SHIFTR = (uint32_t)0x00000000;
  bc:	4b16      	ldr	r3, [pc, #88]	; (118 <RTC_DeInit+0x118>)
  be:	f04f 0200 	mov.w	r2, #0
  c2:	62da      	str	r2, [r3, #44]	; 0x2c
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:419
      RTC->CALR = (uint32_t)0x00000000;
  c4:	4b14      	ldr	r3, [pc, #80]	; (118 <RTC_DeInit+0x118>)
  c6:	f04f 0200 	mov.w	r2, #0
  ca:	63da      	str	r2, [r3, #60]	; 0x3c
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:420
      RTC->ALRMASSR = (uint32_t)0x00000000;
  cc:	4b12      	ldr	r3, [pc, #72]	; (118 <RTC_DeInit+0x118>)
  ce:	f04f 0200 	mov.w	r2, #0
  d2:	645a      	str	r2, [r3, #68]	; 0x44
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:421
      RTC->ALRMBSSR = (uint32_t)0x00000000;
  d4:	4b10      	ldr	r3, [pc, #64]	; (118 <RTC_DeInit+0x118>)
  d6:	f04f 0200 	mov.w	r2, #0
  da:	649a      	str	r2, [r3, #72]	; 0x48
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:424
      
      /* Reset ISR register and exit initialization mode */
      RTC->ISR = (uint32_t)0x00000000;
  dc:	4b0e      	ldr	r3, [pc, #56]	; (118 <RTC_DeInit+0x118>)
  de:	f04f 0200 	mov.w	r2, #0
  e2:	60da      	str	r2, [r3, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:427
      
      /* Reset Tamper and alternate functions configuration register */
      RTC->TAFCR = 0x00000000;
  e4:	4b0c      	ldr	r3, [pc, #48]	; (118 <RTC_DeInit+0x118>)
  e6:	f04f 0200 	mov.w	r2, #0
  ea:	641a      	str	r2, [r3, #64]	; 0x40
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:429
  
      if(RTC_WaitForSynchro() == ERROR)
  ec:	f7ff fffe 	bl	0 <RTC_DeInit>
  f0:	4603      	mov	r3, r0
  f2:	2b00      	cmp	r3, #0
  f4:	d103      	bne.n	fe <RTC_DeInit+0xfe>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:431
      {
        status = ERROR;
  f6:	f04f 0300 	mov.w	r3, #0
  fa:	73fb      	strb	r3, [r7, #15]
  fc:	e002      	b.n	104 <RTC_DeInit+0x104>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:435
      }
      else
      {
        status = SUCCESS;      
  fe:	f04f 0301 	mov.w	r3, #1
 102:	73fb      	strb	r3, [r7, #15]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:441
      }
    }
  }
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;  
 104:	4b04      	ldr	r3, [pc, #16]	; (118 <RTC_DeInit+0x118>)
 106:	f04f 02ff 	mov.w	r2, #255	; 0xff
 10a:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:443
  
  return status;
 10c:	7bfb      	ldrb	r3, [r7, #15]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:444
}
 10e:	4618      	mov	r0, r3
 110:	f107 0710 	add.w	r7, r7, #16
 114:	46bd      	mov	sp, r7
 116:	bd80      	pop	{r7, pc}
 118:	40002800 	.word	0x40002800
 11c:	007f00ff 	.word	0x007f00ff

Disassembly of section .text.RTC_Init:

00000000 <RTC_Init>:
RTC_Init():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:458
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC registers are initialized
  *          - ERROR: RTC registers are not initialized  
  */
ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
{
   0:	b084b580 	.word	0xb084b580
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:459
  ErrorStatus status = ERROR;
   8:	f04f 0300 	mov.w	r3, #0
   c:	73fb      	strb	r3, [r7, #15]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:467
  assert_param(IS_RTC_HOUR_FORMAT(RTC_InitStruct->RTC_HourFormat));
  assert_param(IS_RTC_ASYNCH_PREDIV(RTC_InitStruct->RTC_AsynchPrediv));
  assert_param(IS_RTC_SYNCH_PREDIV(RTC_InitStruct->RTC_SynchPrediv));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
   e:	4b1e      	ldr	r3, [pc, #120]	; (88 <RTC_Init+0x88>)
  10:	f04f 02ca 	mov.w	r2, #202	; 0xca
  14:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:468
  RTC->WPR = 0x53;
  16:	4b1c      	ldr	r3, [pc, #112]	; (88 <RTC_Init+0x88>)
  18:	f04f 0253 	mov.w	r2, #83	; 0x53
  1c:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:471

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
  1e:	f7ff fffe 	bl	0 <RTC_Init>
  22:	4603      	mov	r3, r0
  24:	2b00      	cmp	r3, #0
  26:	d103      	bne.n	30 <RTC_Init+0x30>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:473
  {
    status = ERROR;
  28:	f04f 0300 	mov.w	r3, #0
  2c:	73fb      	strb	r3, [r7, #15]
  2e:	e020      	b.n	72 <RTC_Init+0x72>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:478
  } 
  else
  {
    /* Clear RTC CR FMT Bit */
    RTC->CR &= ((uint32_t)~(RTC_CR_FMT));
  30:	4b15      	ldr	r3, [pc, #84]	; (88 <RTC_Init+0x88>)
  32:	4a15      	ldr	r2, [pc, #84]	; (88 <RTC_Init+0x88>)
  34:	6892      	ldr	r2, [r2, #8]
  36:	f022 0240 	bic.w	r2, r2, #64	; 0x40
  3a:	609a      	str	r2, [r3, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:480
    /* Set RTC_CR register */
    RTC->CR |=  ((uint32_t)(RTC_InitStruct->RTC_HourFormat));
  3c:	4b12      	ldr	r3, [pc, #72]	; (88 <RTC_Init+0x88>)
  3e:	4a12      	ldr	r2, [pc, #72]	; (88 <RTC_Init+0x88>)
  40:	6891      	ldr	r1, [r2, #8]
  42:	687a      	ldr	r2, [r7, #4]
  44:	6812      	ldr	r2, [r2, #0]
  46:	ea41 0202 	orr.w	r2, r1, r2
  4a:	609a      	str	r2, [r3, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:483
  
    /* Configure the RTC PRER */
    RTC->PRER = (uint32_t)(RTC_InitStruct->RTC_SynchPrediv);
  4c:	4b0e      	ldr	r3, [pc, #56]	; (88 <RTC_Init+0x88>)
  4e:	687a      	ldr	r2, [r7, #4]
  50:	6892      	ldr	r2, [r2, #8]
  52:	611a      	str	r2, [r3, #16]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:484
    RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);
  54:	4b0c      	ldr	r3, [pc, #48]	; (88 <RTC_Init+0x88>)
  56:	4a0c      	ldr	r2, [pc, #48]	; (88 <RTC_Init+0x88>)
  58:	6911      	ldr	r1, [r2, #16]
  5a:	687a      	ldr	r2, [r7, #4]
  5c:	6852      	ldr	r2, [r2, #4]
  5e:	ea4f 4202 	mov.w	r2, r2, lsl #16
  62:	ea41 0202 	orr.w	r2, r1, r2
  66:	611a      	str	r2, [r3, #16]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:487

    /* Exit Initialization mode */
    RTC_ExitInitMode();
  68:	f7ff fffe 	bl	0 <RTC_Init>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:489

    status = SUCCESS;    
  6c:	f04f 0301 	mov.w	r3, #1
  70:	73fb      	strb	r3, [r7, #15]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:492
  }
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
  72:	4b05      	ldr	r3, [pc, #20]	; (88 <RTC_Init+0x88>)
  74:	f04f 02ff 	mov.w	r2, #255	; 0xff
  78:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:494
  
  return status;
  7a:	7bfb      	ldrb	r3, [r7, #15]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:495
}
  7c:	4618      	mov	r0, r3
  7e:	f107 0710 	add.w	r7, r7, #16
  82:	46bd      	mov	sp, r7
  84:	bd80      	pop	{r7, pc}
  86:	bf00      	nop
  88:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_StructInit:

00000000 <RTC_StructInit>:
RTC_StructInit():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:504
  * @param  RTC_InitStruct: pointer to a RTC_InitTypeDef structure which will be 
  *         initialized.
  * @retval None
  */
void RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:506
  /* Initialize the RTC_HourFormat member */
  RTC_InitStruct->RTC_HourFormat = RTC_HourFormat_24;
   8:	687b      	ldr	r3, [r7, #4]
   a:	f04f 0200 	mov.w	r2, #0
   e:	601a      	str	r2, [r3, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:509
    
  /* Initialize the RTC_AsynchPrediv member */
  RTC_InitStruct->RTC_AsynchPrediv = (uint32_t)0x7F;
  10:	687b      	ldr	r3, [r7, #4]
  12:	f04f 027f 	mov.w	r2, #127	; 0x7f
  16:	605a      	str	r2, [r3, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:512

  /* Initialize the RTC_SynchPrediv member */
  RTC_InitStruct->RTC_SynchPrediv = (uint32_t)0xFF; 
  18:	687b      	ldr	r3, [r7, #4]
  1a:	f04f 02ff 	mov.w	r2, #255	; 0xff
  1e:	609a      	str	r2, [r3, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:513
}
  20:	f107 070c 	add.w	r7, r7, #12
  24:	46bd      	mov	sp, r7
  26:	bc80      	pop	{r7}
  28:	4770      	bx	lr
  2a:	bf00      	nop

Disassembly of section .text.RTC_WriteProtectionCmd:

00000000 <RTC_WriteProtectionCmd>:
RTC_WriteProtectionCmd():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:526
  * @param  NewState: new state of the write protection.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RTC_WriteProtectionCmd(FunctionalState NewState)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	4603      	mov	r3, r0
   8:	71fb      	strb	r3, [r7, #7]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:530
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
   a:	79fb      	ldrb	r3, [r7, #7]
   c:	2b00      	cmp	r3, #0
   e:	d004      	beq.n	1a <RTC_WriteProtectionCmd+0x1a>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:533
  {
    /* Enable the write protection for RTC registers */
    RTC->WPR = 0xFF;   
  10:	4b08      	ldr	r3, [pc, #32]	; (34 <RTC_WriteProtectionCmd+0x34>)
  12:	f04f 02ff 	mov.w	r2, #255	; 0xff
  16:	625a      	str	r2, [r3, #36]	; 0x24
  18:	e007      	b.n	2a <RTC_WriteProtectionCmd+0x2a>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:538
  }
  else
  {
    /* Disable the write protection for RTC registers */
    RTC->WPR = 0xCA;
  1a:	4b06      	ldr	r3, [pc, #24]	; (34 <RTC_WriteProtectionCmd+0x34>)
  1c:	f04f 02ca 	mov.w	r2, #202	; 0xca
  20:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:539
    RTC->WPR = 0x53;    
  22:	4b04      	ldr	r3, [pc, #16]	; (34 <RTC_WriteProtectionCmd+0x34>)
  24:	f04f 0253 	mov.w	r2, #83	; 0x53
  28:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:541
  }
}
  2a:	f107 070c 	add.w	r7, r7, #12
  2e:	46bd      	mov	sp, r7
  30:	bc80      	pop	{r7}
  32:	4770      	bx	lr
  34:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_EnterInitMode:

00000000 <RTC_EnterInitMode>:
RTC_EnterInitMode():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:553
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC is in Init mode
  *          - ERROR: RTC is not in Init mode  
  */
ErrorStatus RTC_EnterInitMode(void)
{
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:554
  __IO uint32_t initcounter = 0x00;
   6:	f04f 0300 	mov.w	r3, #0
   a:	607b      	str	r3, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:555
  ErrorStatus status = ERROR;
   c:	f04f 0300 	mov.w	r3, #0
  10:	73fb      	strb	r3, [r7, #15]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:556
  uint32_t initstatus = 0x00;
  12:	f04f 0300 	mov.w	r3, #0
  16:	60bb      	str	r3, [r7, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:559
     
  /* Check if the Initialization mode is set */
  if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
  18:	4b18      	ldr	r3, [pc, #96]	; (7c <RTC_EnterInitMode+0x7c>)
  1a:	68db      	ldr	r3, [r3, #12]
  1c:	f003 0340 	and.w	r3, r3, #64	; 0x40
  20:	2b00      	cmp	r3, #0
  22:	d121      	bne.n	68 <RTC_EnterInitMode+0x68>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:562
  {
    /* Set the Initialization mode */
    RTC->ISR = (uint32_t)RTC_INIT_MASK;
  24:	4b15      	ldr	r3, [pc, #84]	; (7c <RTC_EnterInitMode+0x7c>)
  26:	f04f 32ff 	mov.w	r2, #4294967295
  2a:	60da      	str	r2, [r3, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:567
    
    /* Wait till RTC is in INIT state and if Time out is reached exit */
    do
    {
      initstatus = RTC->ISR & RTC_ISR_INITF;
  2c:	4b13      	ldr	r3, [pc, #76]	; (7c <RTC_EnterInitMode+0x7c>)
  2e:	68db      	ldr	r3, [r3, #12]
  30:	f003 0340 	and.w	r3, r3, #64	; 0x40
  34:	60bb      	str	r3, [r7, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:568
      initcounter++;  
  36:	687b      	ldr	r3, [r7, #4]
  38:	f103 0301 	add.w	r3, r3, #1
  3c:	607b      	str	r3, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:569
    } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
  3e:	687b      	ldr	r3, [r7, #4]
  40:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
  44:	d002      	beq.n	4c <RTC_EnterInitMode+0x4c>
  46:	68bb      	ldr	r3, [r7, #8]
  48:	2b00      	cmp	r3, #0
  4a:	d0ef      	beq.n	2c <RTC_EnterInitMode+0x2c>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:571
    
    if ((RTC->ISR & RTC_ISR_INITF) != RESET)
  4c:	4b0b      	ldr	r3, [pc, #44]	; (7c <RTC_EnterInitMode+0x7c>)
  4e:	68db      	ldr	r3, [r3, #12]
  50:	f003 0340 	and.w	r3, r3, #64	; 0x40
  54:	2b00      	cmp	r3, #0
  56:	d003      	beq.n	60 <RTC_EnterInitMode+0x60>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:573
    {
      status = SUCCESS;
  58:	f04f 0301 	mov.w	r3, #1
  5c:	73fb      	strb	r3, [r7, #15]
  5e:	e006      	b.n	6e <RTC_EnterInitMode+0x6e>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:577
    }
    else
    {
      status = ERROR;
  60:	f04f 0300 	mov.w	r3, #0
  64:	73fb      	strb	r3, [r7, #15]
  66:	e002      	b.n	6e <RTC_EnterInitMode+0x6e>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:582
    }        
  }
  else
  {
    status = SUCCESS;  
  68:	f04f 0301 	mov.w	r3, #1
  6c:	73fb      	strb	r3, [r7, #15]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:585
  } 
    
  return (status);  
  6e:	7bfb      	ldrb	r3, [r7, #15]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:586
}
  70:	4618      	mov	r0, r3
  72:	f107 0714 	add.w	r7, r7, #20
  76:	46bd      	mov	sp, r7
  78:	bc80      	pop	{r7}
  7a:	4770      	bx	lr
  7c:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_ExitInitMode:

00000000 <RTC_ExitInitMode>:
RTC_ExitInitMode():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:598
  *         RTC_WriteProtectionCmd(DISABLE) before calling this function.      
  * @param  None
  * @retval None
  */
void RTC_ExitInitMode(void)
{ 
   0:	af00b480 	.word	0xaf00b480
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:600
  /* Exit Initialization mode */
  RTC->ISR &= (uint32_t)~RTC_ISR_INIT;  
   4:	4b04      	ldr	r3, [pc, #16]	; (18 <RTC_ExitInitMode+0x18>)
   6:	4a04      	ldr	r2, [pc, #16]	; (18 <RTC_ExitInitMode+0x18>)
   8:	68d2      	ldr	r2, [r2, #12]
   a:	f022 0280 	bic.w	r2, r2, #128	; 0x80
   e:	60da      	str	r2, [r3, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:601
}
  10:	46bd      	mov	sp, r7
  12:	bc80      	pop	{r7}
  14:	4770      	bx	lr
  16:	bf00      	nop
  18:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_WaitForSynchro:

00000000 <RTC_WaitForSynchro>:
RTC_WaitForSynchro():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:620
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC registers are synchronised
  *          - ERROR: RTC registers are not synchronised
  */
ErrorStatus RTC_WaitForSynchro(void)
{
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:621
  __IO uint32_t synchrocounter = 0;
   6:	f04f 0300 	mov.w	r3, #0
   a:	607b      	str	r3, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:622
  ErrorStatus status = ERROR;
   c:	f04f 0300 	mov.w	r3, #0
  10:	73fb      	strb	r3, [r7, #15]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:623
  uint32_t synchrostatus = 0x00;
  12:	f04f 0300 	mov.w	r3, #0
  16:	60bb      	str	r3, [r7, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:626

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  18:	4b1a      	ldr	r3, [pc, #104]	; (84 <RTC_WaitForSynchro+0x84>)
  1a:	f04f 02ca 	mov.w	r2, #202	; 0xca
  1e:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:627
  RTC->WPR = 0x53;
  20:	4b18      	ldr	r3, [pc, #96]	; (84 <RTC_WaitForSynchro+0x84>)
  22:	f04f 0253 	mov.w	r2, #83	; 0x53
  26:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:630
    
  /* Clear RSF flag */
  RTC->ISR &= (uint32_t)RTC_RSF_MASK;
  28:	4b16      	ldr	r3, [pc, #88]	; (84 <RTC_WaitForSynchro+0x84>)
  2a:	4a16      	ldr	r2, [pc, #88]	; (84 <RTC_WaitForSynchro+0x84>)
  2c:	68d2      	ldr	r2, [r2, #12]
  2e:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
  32:	60da      	str	r2, [r3, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:635
    
  /* Wait the registers to be synchronised */
  do
  {
    synchrostatus = RTC->ISR & RTC_ISR_RSF;
  34:	4b13      	ldr	r3, [pc, #76]	; (84 <RTC_WaitForSynchro+0x84>)
  36:	68db      	ldr	r3, [r3, #12]
  38:	f003 0320 	and.w	r3, r3, #32
  3c:	60bb      	str	r3, [r7, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:636
    synchrocounter++;  
  3e:	687b      	ldr	r3, [r7, #4]
  40:	f103 0301 	add.w	r3, r3, #1
  44:	607b      	str	r3, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:637
  } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
  46:	687b      	ldr	r3, [r7, #4]
  48:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
  4c:	d002      	beq.n	54 <RTC_WaitForSynchro+0x54>
  4e:	68bb      	ldr	r3, [r7, #8]
  50:	2b00      	cmp	r3, #0
  52:	d0ef      	beq.n	34 <RTC_WaitForSynchro+0x34>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:639
    
  if ((RTC->ISR & RTC_ISR_RSF) != RESET)
  54:	4b0b      	ldr	r3, [pc, #44]	; (84 <RTC_WaitForSynchro+0x84>)
  56:	68db      	ldr	r3, [r3, #12]
  58:	f003 0320 	and.w	r3, r3, #32
  5c:	2b00      	cmp	r3, #0
  5e:	d003      	beq.n	68 <RTC_WaitForSynchro+0x68>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:641
  {
    status = SUCCESS;
  60:	f04f 0301 	mov.w	r3, #1
  64:	73fb      	strb	r3, [r7, #15]
  66:	e002      	b.n	6e <RTC_WaitForSynchro+0x6e>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:645
  }
  else
  {
    status = ERROR;
  68:	f04f 0300 	mov.w	r3, #0
  6c:	73fb      	strb	r3, [r7, #15]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:649
  }        

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
  6e:	4b05      	ldr	r3, [pc, #20]	; (84 <RTC_WaitForSynchro+0x84>)
  70:	f04f 02ff 	mov.w	r2, #255	; 0xff
  74:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:651
    
  return (status); 
  76:	7bfb      	ldrb	r3, [r7, #15]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:652
}
  78:	4618      	mov	r0, r3
  7a:	f107 0714 	add.w	r7, r7, #20
  7e:	46bd      	mov	sp, r7
  80:	bc80      	pop	{r7}
  82:	4770      	bx	lr
  84:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_RefClockCmd:

00000000 <RTC_RefClockCmd>:
RTC_RefClockCmd():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:663
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC reference clock detection is enabled
  *          - ERROR: RTC reference clock detection is disabled  
  */
ErrorStatus RTC_RefClockCmd(FunctionalState NewState)
{ 
   0:	b084b580 	.word	0xb084b580
   4:	af00      	add	r7, sp, #0
   6:	4603      	mov	r3, r0
   8:	71fb      	strb	r3, [r7, #7]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:664
  ErrorStatus status = ERROR;
   a:	f04f 0300 	mov.w	r3, #0
   e:	73fb      	strb	r3, [r7, #15]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:670
  
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  10:	4b17      	ldr	r3, [pc, #92]	; (70 <RTC_RefClockCmd+0x70>)
  12:	f04f 02ca 	mov.w	r2, #202	; 0xca
  16:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:671
  RTC->WPR = 0x53;
  18:	4b15      	ldr	r3, [pc, #84]	; (70 <RTC_RefClockCmd+0x70>)
  1a:	f04f 0253 	mov.w	r2, #83	; 0x53
  1e:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:674
    
  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
  20:	f7ff fffe 	bl	0 <RTC_RefClockCmd>
  24:	4603      	mov	r3, r0
  26:	2b00      	cmp	r3, #0
  28:	d103      	bne.n	32 <RTC_RefClockCmd+0x32>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:676
  {
    status = ERROR;
  2a:	f04f 0300 	mov.w	r3, #0
  2e:	73fb      	strb	r3, [r7, #15]
  30:	e014      	b.n	5c <RTC_RefClockCmd+0x5c>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:680
  } 
  else
  {  
    if (NewState != DISABLE)
  32:	79fb      	ldrb	r3, [r7, #7]
  34:	2b00      	cmp	r3, #0
  36:	d006      	beq.n	46 <RTC_RefClockCmd+0x46>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:683
    {
      /* Enable the RTC reference clock detection */
      RTC->CR |= RTC_CR_REFCKON;   
  38:	4b0d      	ldr	r3, [pc, #52]	; (70 <RTC_RefClockCmd+0x70>)
  3a:	4a0d      	ldr	r2, [pc, #52]	; (70 <RTC_RefClockCmd+0x70>)
  3c:	6892      	ldr	r2, [r2, #8]
  3e:	f042 0210 	orr.w	r2, r2, #16
  42:	609a      	str	r2, [r3, #8]
  44:	e005      	b.n	52 <RTC_RefClockCmd+0x52>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:688
    }
    else
    {
      /* Disable the RTC reference clock detection */
      RTC->CR &= ~RTC_CR_REFCKON;    
  46:	4b0a      	ldr	r3, [pc, #40]	; (70 <RTC_RefClockCmd+0x70>)
  48:	4a09      	ldr	r2, [pc, #36]	; (70 <RTC_RefClockCmd+0x70>)
  4a:	6892      	ldr	r2, [r2, #8]
  4c:	f022 0210 	bic.w	r2, r2, #16
  50:	609a      	str	r2, [r3, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:691
    }
    /* Exit Initialization mode */
    RTC_ExitInitMode();
  52:	f7ff fffe 	bl	0 <RTC_RefClockCmd>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:693
    
    status = SUCCESS;
  56:	f04f 0301 	mov.w	r3, #1
  5a:	73fb      	strb	r3, [r7, #15]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:697
  }
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;  
  5c:	4b04      	ldr	r3, [pc, #16]	; (70 <RTC_RefClockCmd+0x70>)
  5e:	f04f 02ff 	mov.w	r2, #255	; 0xff
  62:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:699
  
  return status; 
  64:	7bfb      	ldrb	r3, [r7, #15]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:700
}
  66:	4618      	mov	r0, r3
  68:	f107 0710 	add.w	r7, r7, #16
  6c:	46bd      	mov	sp, r7
  6e:	bd80      	pop	{r7, pc}
  70:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_BypassShadowCmd:

00000000 <RTC_BypassShadowCmd>:
RTC_BypassShadowCmd():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:711
  * @param  NewState: new state of the Bypass Shadow feature.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
*/
void RTC_BypassShadowCmd(FunctionalState NewState)
{
   0:	b083b480 	.word	0xb083b480
   4:	af00      	add	r7, sp, #0
   6:	4603      	mov	r3, r0
   8:	71fb      	strb	r3, [r7, #7]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:716
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
   a:	4b10      	ldr	r3, [pc, #64]	; (4c <RTC_BypassShadowCmd+0x4c>)
   c:	f04f 02ca 	mov.w	r2, #202	; 0xca
  10:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:717
  RTC->WPR = 0x53;
  12:	4b0e      	ldr	r3, [pc, #56]	; (4c <RTC_BypassShadowCmd+0x4c>)
  14:	f04f 0253 	mov.w	r2, #83	; 0x53
  18:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:719
  
  if (NewState != DISABLE)
  1a:	79fb      	ldrb	r3, [r7, #7]
  1c:	2b00      	cmp	r3, #0
  1e:	d006      	beq.n	2e <RTC_BypassShadowCmd+0x2e>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:722
  {
    /* Set the BYPSHAD bit */
    RTC->CR |= (uint8_t)RTC_CR_BYPSHAD;
  20:	4b0a      	ldr	r3, [pc, #40]	; (4c <RTC_BypassShadowCmd+0x4c>)
  22:	4a0a      	ldr	r2, [pc, #40]	; (4c <RTC_BypassShadowCmd+0x4c>)
  24:	6892      	ldr	r2, [r2, #8]
  26:	f042 0220 	orr.w	r2, r2, #32
  2a:	609a      	str	r2, [r3, #8]
  2c:	e005      	b.n	3a <RTC_BypassShadowCmd+0x3a>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:727
  }
  else
  {
    /* Reset the BYPSHAD bit */
    RTC->CR &= (uint8_t)~RTC_CR_BYPSHAD;
  2e:	4b07      	ldr	r3, [pc, #28]	; (4c <RTC_BypassShadowCmd+0x4c>)
  30:	4a06      	ldr	r2, [pc, #24]	; (4c <RTC_BypassShadowCmd+0x4c>)
  32:	6892      	ldr	r2, [r2, #8]
  34:	f002 02df 	and.w	r2, r2, #223	; 0xdf
  38:	609a      	str	r2, [r3, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:731
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
  3a:	4b04      	ldr	r3, [pc, #16]	; (4c <RTC_BypassShadowCmd+0x4c>)
  3c:	f04f 02ff 	mov.w	r2, #255	; 0xff
  40:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:732
}
  42:	f107 070c 	add.w	r7, r7, #12
  46:	46bd      	mov	sp, r7
  48:	bc80      	pop	{r7}
  4a:	4770      	bx	lr
  4c:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_SetTime:

00000000 <RTC_SetTime>:
RTC_SetTime():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:766
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Time register is configured
  *          - ERROR: RTC Time register is not configured
  */
ErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
{
   0:	b590      	push	{r4, r7, lr}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	6039      	str	r1, [r7, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:767
  uint32_t tmpreg = 0;
   a:	f04f 0300 	mov.w	r3, #0
   e:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:768
  ErrorStatus status = ERROR;
  10:	f04f 0300 	mov.w	r3, #0
  14:	72fb      	strb	r3, [r7, #11]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:773
    
  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));
  
  if (RTC_Format == RTC_Format_BIN)
  16:	687b      	ldr	r3, [r7, #4]
  18:	2b00      	cmp	r3, #0
  1a:	d10a      	bne.n	32 <RTC_SetTime+0x32>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:775
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
  1c:	4b46      	ldr	r3, [pc, #280]	; (138 <RTC_SetTime+0x138>)
  1e:	689b      	ldr	r3, [r3, #8]
  20:	f003 0340 	and.w	r3, r3, #64	; 0x40
  24:	2b00      	cmp	r3, #0
  26:	d116      	bne.n	56 <RTC_SetTime+0x56>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:782
      assert_param(IS_RTC_HOUR12(RTC_TimeStruct->RTC_Hours));
      assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12));
    } 
    else
    {
      RTC_TimeStruct->RTC_H12 = 0x00;
  28:	683b      	ldr	r3, [r7, #0]
  2a:	f04f 0200 	mov.w	r2, #0
  2e:	70da      	strb	r2, [r3, #3]
  30:	e011      	b.n	56 <RTC_SetTime+0x56>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:790
    assert_param(IS_RTC_MINUTES(RTC_TimeStruct->RTC_Minutes));
    assert_param(IS_RTC_SECONDS(RTC_TimeStruct->RTC_Seconds));
  }
  else
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
  32:	4b41      	ldr	r3, [pc, #260]	; (138 <RTC_SetTime+0x138>)
  34:	689b      	ldr	r3, [r3, #8]
  36:	f003 0340 	and.w	r3, r3, #64	; 0x40
  3a:	2b00      	cmp	r3, #0
  3c:	d007      	beq.n	4e <RTC_SetTime+0x4e>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:792
    {
      tmpreg = RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
  3e:	683b      	ldr	r3, [r7, #0]
  40:	781b      	ldrb	r3, [r3, #0]
  42:	4618      	mov	r0, r3
  44:	f7ff fffe 	bl	0 <RTC_SetTime>
  48:	4603      	mov	r3, r0
  4a:	60fb      	str	r3, [r7, #12]
  4c:	e003      	b.n	56 <RTC_SetTime+0x56>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:798
      assert_param(IS_RTC_HOUR12(tmpreg));
      assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12)); 
    } 
    else
    {
      RTC_TimeStruct->RTC_H12 = 0x00;
  4e:	683b      	ldr	r3, [r7, #0]
  50:	f04f 0200 	mov.w	r2, #0
  54:	70da      	strb	r2, [r3, #3]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:806
    assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes)));
    assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds)));
  }
  
  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  56:	687b      	ldr	r3, [r7, #4]
  58:	2b00      	cmp	r3, #0
  5a:	d013      	beq.n	84 <RTC_SetTime+0x84>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:808
  {
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
  5c:	683b      	ldr	r3, [r7, #0]
  5e:	781b      	ldrb	r3, [r3, #0]
  60:	ea4f 4203 	mov.w	r2, r3, lsl #16
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:809
             ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
  64:	683b      	ldr	r3, [r7, #0]
  66:	785b      	ldrb	r3, [r3, #1]
  68:	ea4f 2303 	mov.w	r3, r3, lsl #8
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:808
  }
  
  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
  6c:	431a      	orrs	r2, r3
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:810
             ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
             ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
  6e:	683b      	ldr	r3, [r7, #0]
  70:	789b      	ldrb	r3, [r3, #2]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:809
  
  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
             ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
  72:	431a      	orrs	r2, r3
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:811
             ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
             ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
  74:	683b      	ldr	r3, [r7, #0]
  76:	78db      	ldrb	r3, [r3, #3]
  78:	ea4f 4303 	mov.w	r3, r3, lsl #16
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:808
  }
  
  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
  7c:	ea42 0303 	orr.w	r3, r2, r3
  80:	60fb      	str	r3, [r7, #12]
  82:	e01f      	b.n	c4 <RTC_SetTime+0xc4>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:815
             ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
             ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
  }  
  else
  {
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
  84:	683b      	ldr	r3, [r7, #0]
  86:	781b      	ldrb	r3, [r3, #0]
  88:	4618      	mov	r0, r3
  8a:	f7ff fffe 	bl	0 <RTC_SetTime>
  8e:	4603      	mov	r3, r0
  90:	ea4f 4403 	mov.w	r4, r3, lsl #16
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:816
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
  94:	683b      	ldr	r3, [r7, #0]
  96:	785b      	ldrb	r3, [r3, #1]
  98:	4618      	mov	r0, r3
  9a:	f7ff fffe 	bl	0 <RTC_SetTime>
  9e:	4603      	mov	r3, r0
  a0:	ea4f 2303 	mov.w	r3, r3, lsl #8
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:815
             ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
             ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
  }  
  else
  {
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
  a4:	431c      	orrs	r4, r3
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:817
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
  a6:	683b      	ldr	r3, [r7, #0]
  a8:	789b      	ldrb	r3, [r3, #2]
  aa:	4618      	mov	r0, r3
  ac:	f7ff fffe 	bl	0 <RTC_SetTime>
  b0:	4603      	mov	r3, r0
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:816
             ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
  }  
  else
  {
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
  b2:	ea44 0203 	orr.w	r2, r4, r3
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:818
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
                   (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
  b6:	683b      	ldr	r3, [r7, #0]
  b8:	78db      	ldrb	r3, [r3, #3]
  ba:	ea4f 4303 	mov.w	r3, r3, lsl #16
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:815
             ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
             ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
  }  
  else
  {
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
  be:	ea42 0303 	orr.w	r3, r2, r3
  c2:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:822
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
                   (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
  }  

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  c4:	4b1c      	ldr	r3, [pc, #112]	; (138 <RTC_SetTime+0x138>)
  c6:	f04f 02ca 	mov.w	r2, #202	; 0xca
  ca:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:823
  RTC->WPR = 0x53;
  cc:	4b1a      	ldr	r3, [pc, #104]	; (138 <RTC_SetTime+0x138>)
  ce:	f04f 0253 	mov.w	r2, #83	; 0x53
  d2:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:826

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
  d4:	f7ff fffe 	bl	0 <RTC_SetTime>
  d8:	4603      	mov	r3, r0
  da:	2b00      	cmp	r3, #0
  dc:	d103      	bne.n	e6 <RTC_SetTime+0xe6>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:828
  {
    status = ERROR;
  de:	f04f 0300 	mov.w	r3, #0
  e2:	72fb      	strb	r3, [r7, #11]
  e4:	e01d      	b.n	122 <RTC_SetTime+0x122>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:833
  } 
  else
  {
    /* Set the RTC_TR register */
    RTC->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
  e6:	4a14      	ldr	r2, [pc, #80]	; (138 <RTC_SetTime+0x138>)
  e8:	68f9      	ldr	r1, [r7, #12]
  ea:	4b14      	ldr	r3, [pc, #80]	; (13c <RTC_SetTime+0x13c>)
  ec:	ea01 0303 	and.w	r3, r1, r3
  f0:	6013      	str	r3, [r2, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:836

    /* Exit Initialization mode */
    RTC_ExitInitMode(); 
  f2:	f7ff fffe 	bl	0 <RTC_SetTime>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:839

    /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
  f6:	4b10      	ldr	r3, [pc, #64]	; (138 <RTC_SetTime+0x138>)
  f8:	689b      	ldr	r3, [r3, #8]
  fa:	f003 0320 	and.w	r3, r3, #32
  fe:	2b00      	cmp	r3, #0
 100:	d10c      	bne.n	11c <RTC_SetTime+0x11c>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:841
    {
    if(RTC_WaitForSynchro() == ERROR)
 102:	f7ff fffe 	bl	0 <RTC_SetTime>
 106:	4603      	mov	r3, r0
 108:	2b00      	cmp	r3, #0
 10a:	d103      	bne.n	114 <RTC_SetTime+0x114>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:843
    {
      status = ERROR;
 10c:	f04f 0300 	mov.w	r3, #0
 110:	72fb      	strb	r3, [r7, #11]
 112:	e006      	b.n	122 <RTC_SetTime+0x122>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:847
    }
    else
    {
      status = SUCCESS;
 114:	f04f 0301 	mov.w	r3, #1
 118:	72fb      	strb	r3, [r7, #11]
 11a:	e002      	b.n	122 <RTC_SetTime+0x122>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:852
    }
  }
    else
    {
      status = SUCCESS;
 11c:	f04f 0301 	mov.w	r3, #1
 120:	72fb      	strb	r3, [r7, #11]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:856
    }
  }
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
 122:	4b05      	ldr	r3, [pc, #20]	; (138 <RTC_SetTime+0x138>)
 124:	f04f 02ff 	mov.w	r2, #255	; 0xff
 128:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:858
    
  return status;
 12a:	7afb      	ldrb	r3, [r7, #11]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:859
}
 12c:	4618      	mov	r0, r3
 12e:	f107 0714 	add.w	r7, r7, #20
 132:	46bd      	mov	sp, r7
 134:	bd90      	pop	{r4, r7, pc}
 136:	bf00      	nop
 138:	40002800 	.word	0x40002800
 13c:	007f7f7f 	.word	0x007f7f7f

Disassembly of section .text.RTC_TimeStructInit:

00000000 <RTC_TimeStructInit>:
RTC_TimeStructInit():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:869
  * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure which will be 
  *         initialized.
  * @retval None
  */
void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:871
  /* Time = 00h:00min:00sec */
  RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
   8:	687b      	ldr	r3, [r7, #4]
   a:	f04f 0200 	mov.w	r2, #0
   e:	70da      	strb	r2, [r3, #3]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:872
  RTC_TimeStruct->RTC_Hours = 0;
  10:	687b      	ldr	r3, [r7, #4]
  12:	f04f 0200 	mov.w	r2, #0
  16:	701a      	strb	r2, [r3, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:873
  RTC_TimeStruct->RTC_Minutes = 0;
  18:	687b      	ldr	r3, [r7, #4]
  1a:	f04f 0200 	mov.w	r2, #0
  1e:	705a      	strb	r2, [r3, #1]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:874
  RTC_TimeStruct->RTC_Seconds = 0; 
  20:	687b      	ldr	r3, [r7, #4]
  22:	f04f 0200 	mov.w	r2, #0
  26:	709a      	strb	r2, [r3, #2]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:875
}
  28:	f107 070c 	add.w	r7, r7, #12
  2c:	46bd      	mov	sp, r7
  2e:	bc80      	pop	{r7}
  30:	4770      	bx	lr
  32:	bf00      	nop

Disassembly of section .text.RTC_GetTime:

00000000 <RTC_GetTime>:
RTC_GetTime():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:888
  * @param  RTC_TimeStruct: pointer to a RTC_TimeTypeDef structure that will 
  *                        contain the returned current time configuration.     
  * @retval None
  */
void RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
{
   0:	b580      	push	{r7, lr}
   2:	b084      	sub	sp, #16
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	6039      	str	r1, [r7, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:889
  uint32_t tmpreg = 0;
   a:	f04f 0300 	mov.w	r3, #0
   e:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:895

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));

  /* Get the RTC_TR register */
  tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
  10:	4b23      	ldr	r3, [pc, #140]	; (a0 <RTC_GetTime+0xa0>)
  12:	681a      	ldr	r2, [r3, #0]
  14:	4b23      	ldr	r3, [pc, #140]	; (a4 <RTC_GetTime+0xa4>)
  16:	ea02 0303 	and.w	r3, r2, r3
  1a:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:898
  
  /* Fill the structure fields with the read parameters */
  RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
  1c:	68fb      	ldr	r3, [r7, #12]
  1e:	f403 137c 	and.w	r3, r3, #4128768	; 0x3f0000
  22:	ea4f 4313 	mov.w	r3, r3, lsr #16
  26:	b2da      	uxtb	r2, r3
  28:	683b      	ldr	r3, [r7, #0]
  2a:	701a      	strb	r2, [r3, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:899
  RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
  2c:	68fb      	ldr	r3, [r7, #12]
  2e:	f403 43fe 	and.w	r3, r3, #32512	; 0x7f00
  32:	ea4f 2313 	mov.w	r3, r3, lsr #8
  36:	b2da      	uxtb	r2, r3
  38:	683b      	ldr	r3, [r7, #0]
  3a:	705a      	strb	r2, [r3, #1]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:900
  RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
  3c:	68fb      	ldr	r3, [r7, #12]
  3e:	b2db      	uxtb	r3, r3
  40:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  44:	b2da      	uxtb	r2, r3
  46:	683b      	ldr	r3, [r7, #0]
  48:	709a      	strb	r2, [r3, #2]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:901
  RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
  4a:	68fb      	ldr	r3, [r7, #12]
  4c:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
  50:	ea4f 4313 	mov.w	r3, r3, lsr #16
  54:	b2da      	uxtb	r2, r3
  56:	683b      	ldr	r3, [r7, #0]
  58:	70da      	strb	r2, [r3, #3]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:904

  /* Check the input parameters format */
  if (RTC_Format == RTC_Format_BIN)
  5a:	687b      	ldr	r3, [r7, #4]
  5c:	2b00      	cmp	r3, #0
  5e:	d11a      	bne.n	96 <RTC_GetTime+0x96>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:907
  {
    /* Convert the structure parameters to Binary format */
    RTC_TimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
  60:	683b      	ldr	r3, [r7, #0]
  62:	781b      	ldrb	r3, [r3, #0]
  64:	4618      	mov	r0, r3
  66:	f7ff fffe 	bl	0 <RTC_GetTime>
  6a:	4603      	mov	r3, r0
  6c:	461a      	mov	r2, r3
  6e:	683b      	ldr	r3, [r7, #0]
  70:	701a      	strb	r2, [r3, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:908
    RTC_TimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
  72:	683b      	ldr	r3, [r7, #0]
  74:	785b      	ldrb	r3, [r3, #1]
  76:	4618      	mov	r0, r3
  78:	f7ff fffe 	bl	0 <RTC_GetTime>
  7c:	4603      	mov	r3, r0
  7e:	461a      	mov	r2, r3
  80:	683b      	ldr	r3, [r7, #0]
  82:	705a      	strb	r2, [r3, #1]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:909
    RTC_TimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);   
  84:	683b      	ldr	r3, [r7, #0]
  86:	789b      	ldrb	r3, [r3, #2]
  88:	4618      	mov	r0, r3
  8a:	f7ff fffe 	bl	0 <RTC_GetTime>
  8e:	4603      	mov	r3, r0
  90:	461a      	mov	r2, r3
  92:	683b      	ldr	r3, [r7, #0]
  94:	709a      	strb	r2, [r3, #2]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:911
  }
}
  96:	f107 0710 	add.w	r7, r7, #16
  9a:	46bd      	mov	sp, r7
  9c:	bd80      	pop	{r7, pc}
  9e:	bf00      	nop
  a0:	40002800 	.word	0x40002800
  a4:	007f7f7f 	.word	0x007f7f7f

Disassembly of section .text.RTC_GetSubSecond:

00000000 <RTC_GetSubSecond>:
RTC_GetSubSecond():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:921
  *         SSR register.
  * @param  None
  * @retval RTC current Calendar Sub seconds value.
  */
uint32_t RTC_GetSubSecond(void)
{
   0:	b083b480 	.word	0xb083b480
   4:	af00      	add	r7, sp, #0
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:922
  uint32_t tmpreg = 0;
   6:	f04f 0300 	mov.w	r3, #0
   a:	607b      	str	r3, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:925
  
  /* Get sub seconds values from the correspondent registers*/
  tmpreg = (uint32_t)(RTC->SSR);
   c:	4b05      	ldr	r3, [pc, #20]	; (24 <RTC_GetSubSecond+0x24>)
   e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  10:	607b      	str	r3, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:928
  
  /* Read DR register to unfroze calendar registers */
  (void) (RTC->DR);
  12:	4b04      	ldr	r3, [pc, #16]	; (24 <RTC_GetSubSecond+0x24>)
  14:	685b      	ldr	r3, [r3, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:930
  
  return (tmpreg);
  16:	687b      	ldr	r3, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:931
}
  18:	4618      	mov	r0, r3
  1a:	f107 070c 	add.w	r7, r7, #12
  1e:	46bd      	mov	sp, r7
  20:	bc80      	pop	{r7}
  22:	4770      	bx	lr
  24:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_SetDate:

00000000 <RTC_SetDate>:
RTC_SetDate():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:946
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Date register is configured
  *          - ERROR: RTC Date register is not configured
  */
ErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
{
   0:	b590      	push	{r4, r7, lr}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	6039      	str	r1, [r7, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:947
  uint32_t tmpreg = 0;
   a:	f04f 0300 	mov.w	r3, #0
   e:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:948
  ErrorStatus status = ERROR;
  10:	f04f 0300 	mov.w	r3, #0
  14:	72fb      	strb	r3, [r7, #11]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:953
  
  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));

  if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & 0x10) == 0x10))
  16:	687b      	ldr	r3, [r7, #4]
  18:	2b00      	cmp	r3, #0
  1a:	d10f      	bne.n	3c <RTC_SetDate+0x3c>
  1c:	683b      	ldr	r3, [r7, #0]
  1e:	785b      	ldrb	r3, [r3, #1]
  20:	f003 0310 	and.w	r3, r3, #16
  24:	2b00      	cmp	r3, #0
  26:	d009      	beq.n	3c <RTC_SetDate+0x3c>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:955
  {
    RTC_DateStruct->RTC_Month = (RTC_DateStruct->RTC_Month & (uint32_t)~(0x10)) + 0x0A;
  28:	683b      	ldr	r3, [r7, #0]
  2a:	785b      	ldrb	r3, [r3, #1]
  2c:	f023 0310 	bic.w	r3, r3, #16
  30:	b2db      	uxtb	r3, r3
  32:	f103 030a 	add.w	r3, r3, #10
  36:	b2da      	uxtb	r2, r3
  38:	683b      	ldr	r3, [r7, #0]
  3a:	705a      	strb	r2, [r3, #1]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:957
  }  
  if (RTC_Format == RTC_Format_BIN)
  3c:	687b      	ldr	r3, [r7, #4]
  3e:	2b00      	cmp	r3, #0
  40:	d00d      	beq.n	5e <RTC_SetDate+0x5e>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:966
    assert_param(IS_RTC_DATE(RTC_DateStruct->RTC_Date));
  }
  else
  {
    assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year)));
    tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
  42:	683b      	ldr	r3, [r7, #0]
  44:	785b      	ldrb	r3, [r3, #1]
  46:	4618      	mov	r0, r3
  48:	f7ff fffe 	bl	0 <RTC_SetDate>
  4c:	4603      	mov	r3, r0
  4e:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:968
    assert_param(IS_RTC_MONTH(tmpreg));
    tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
  50:	683b      	ldr	r3, [r7, #0]
  52:	789b      	ldrb	r3, [r3, #2]
  54:	4618      	mov	r0, r3
  56:	f7ff fffe 	bl	0 <RTC_SetDate>
  5a:	4603      	mov	r3, r0
  5c:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:974
    assert_param(IS_RTC_DATE(tmpreg));
  }
  assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  5e:	687b      	ldr	r3, [r7, #4]
  60:	2b00      	cmp	r3, #0
  62:	d013      	beq.n	8c <RTC_SetDate+0x8c>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:976
  {
    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
  64:	683b      	ldr	r3, [r7, #0]
  66:	78db      	ldrb	r3, [r3, #3]
  68:	ea4f 4203 	mov.w	r2, r3, lsl #16
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:977
              (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
  6c:	683b      	ldr	r3, [r7, #0]
  6e:	785b      	ldrb	r3, [r3, #1]
  70:	ea4f 2303 	mov.w	r3, r3, lsl #8
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:976
  assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
  74:	431a      	orrs	r2, r3
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:978
              (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
              ((uint32_t)RTC_DateStruct->RTC_Date) | \
  76:	683b      	ldr	r3, [r7, #0]
  78:	789b      	ldrb	r3, [r3, #2]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:977

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
              (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
  7a:	431a      	orrs	r2, r3
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:979
              ((uint32_t)RTC_DateStruct->RTC_Date) | \
              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
  7c:	683b      	ldr	r3, [r7, #0]
  7e:	781b      	ldrb	r3, [r3, #0]
  80:	ea4f 3343 	mov.w	r3, r3, lsl #13
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:976
  assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
  84:	ea42 0303 	orr.w	r3, r2, r3
  88:	60fb      	str	r3, [r7, #12]
  8a:	e01f      	b.n	cc <RTC_SetDate+0xcc>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:983
              ((uint32_t)RTC_DateStruct->RTC_Date) | \
              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
  8c:	683b      	ldr	r3, [r7, #0]
  8e:	78db      	ldrb	r3, [r3, #3]
  90:	4618      	mov	r0, r3
  92:	f7ff fffe 	bl	0 <RTC_SetDate>
  96:	4603      	mov	r3, r0
  98:	ea4f 4403 	mov.w	r4, r3, lsl #16
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:984
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
  9c:	683b      	ldr	r3, [r7, #0]
  9e:	785b      	ldrb	r3, [r3, #1]
  a0:	4618      	mov	r0, r3
  a2:	f7ff fffe 	bl	0 <RTC_SetDate>
  a6:	4603      	mov	r3, r0
  a8:	ea4f 2303 	mov.w	r3, r3, lsl #8
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:983
              ((uint32_t)RTC_DateStruct->RTC_Date) | \
              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
  ac:	431c      	orrs	r4, r3
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:985
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
  ae:	683b      	ldr	r3, [r7, #0]
  b0:	789b      	ldrb	r3, [r3, #2]
  b2:	4618      	mov	r0, r3
  b4:	f7ff fffe 	bl	0 <RTC_SetDate>
  b8:	4603      	mov	r3, r0
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:984
              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
  ba:	ea44 0203 	orr.w	r2, r4, r3
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:986
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
              ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
  be:	683b      	ldr	r3, [r7, #0]
  c0:	781b      	ldrb	r3, [r3, #0]
  c2:	ea4f 3343 	mov.w	r3, r3, lsl #13
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:983
              ((uint32_t)RTC_DateStruct->RTC_Date) | \
              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
  c6:	ea42 0303 	orr.w	r3, r2, r3
  ca:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:990
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
              ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
  }

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  cc:	4b1c      	ldr	r3, [pc, #112]	; (140 <RTC_SetDate+0x140>)
  ce:	f04f 02ca 	mov.w	r2, #202	; 0xca
  d2:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:991
  RTC->WPR = 0x53;
  d4:	4b1a      	ldr	r3, [pc, #104]	; (140 <RTC_SetDate+0x140>)
  d6:	f04f 0253 	mov.w	r2, #83	; 0x53
  da:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:994

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
  dc:	f7ff fffe 	bl	0 <RTC_SetDate>
  e0:	4603      	mov	r3, r0
  e2:	2b00      	cmp	r3, #0
  e4:	d103      	bne.n	ee <RTC_SetDate+0xee>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:996
  {
    status = ERROR;
  e6:	f04f 0300 	mov.w	r3, #0
  ea:	72fb      	strb	r3, [r7, #11]
  ec:	e01e      	b.n	12c <RTC_SetDate+0x12c>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1001
  } 
  else
  {
    /* Set the RTC_DR register */
    RTC->DR = (uint32_t)(tmpreg & RTC_DR_RESERVED_MASK);
  ee:	4a14      	ldr	r2, [pc, #80]	; (140 <RTC_SetDate+0x140>)
  f0:	68fb      	ldr	r3, [r7, #12]
  f2:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
  f6:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
  fa:	6053      	str	r3, [r2, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1004

    /* Exit Initialization mode */
    RTC_ExitInitMode(); 
  fc:	f7ff fffe 	bl	0 <RTC_SetDate>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1007

    /* If  RTC_CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
 100:	4b0f      	ldr	r3, [pc, #60]	; (140 <RTC_SetDate+0x140>)
 102:	689b      	ldr	r3, [r3, #8]
 104:	f003 0320 	and.w	r3, r3, #32
 108:	2b00      	cmp	r3, #0
 10a:	d10c      	bne.n	126 <RTC_SetDate+0x126>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1009
    {
    if(RTC_WaitForSynchro() == ERROR)
 10c:	f7ff fffe 	bl	0 <RTC_SetDate>
 110:	4603      	mov	r3, r0
 112:	2b00      	cmp	r3, #0
 114:	d103      	bne.n	11e <RTC_SetDate+0x11e>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1011
    {
      status = ERROR;
 116:	f04f 0300 	mov.w	r3, #0
 11a:	72fb      	strb	r3, [r7, #11]
 11c:	e006      	b.n	12c <RTC_SetDate+0x12c>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1015
    }
    else
    {
      status = SUCCESS;
 11e:	f04f 0301 	mov.w	r3, #1
 122:	72fb      	strb	r3, [r7, #11]
 124:	e002      	b.n	12c <RTC_SetDate+0x12c>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1020
    }
  }
    else
    {
      status = SUCCESS;
 126:	f04f 0301 	mov.w	r3, #1
 12a:	72fb      	strb	r3, [r7, #11]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1024
    }
  }
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;   
 12c:	4b04      	ldr	r3, [pc, #16]	; (140 <RTC_SetDate+0x140>)
 12e:	f04f 02ff 	mov.w	r2, #255	; 0xff
 132:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1026
  
  return status;
 134:	7afb      	ldrb	r3, [r7, #11]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1027
}
 136:	4618      	mov	r0, r3
 138:	f107 0714 	add.w	r7, r7, #20
 13c:	46bd      	mov	sp, r7
 13e:	bd90      	pop	{r4, r7, pc}
 140:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_DateStructInit:

00000000 <RTC_DateStructInit>:
RTC_DateStructInit():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1037
  * @param  RTC_DateStruct: pointer to a RTC_DateTypeDef structure which will be 
  *         initialized.
  * @retval None
  */
void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1039
  /* Monday, January 01 xx00 */
  RTC_DateStruct->RTC_WeekDay = RTC_Weekday_Monday;
   8:	687b      	ldr	r3, [r7, #4]
   a:	f04f 0201 	mov.w	r2, #1
   e:	701a      	strb	r2, [r3, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1040
  RTC_DateStruct->RTC_Date = 1;
  10:	687b      	ldr	r3, [r7, #4]
  12:	f04f 0201 	mov.w	r2, #1
  16:	709a      	strb	r2, [r3, #2]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1041
  RTC_DateStruct->RTC_Month = RTC_Month_January;
  18:	687b      	ldr	r3, [r7, #4]
  1a:	f04f 0201 	mov.w	r2, #1
  1e:	705a      	strb	r2, [r3, #1]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1042
  RTC_DateStruct->RTC_Year = 0;
  20:	687b      	ldr	r3, [r7, #4]
  22:	f04f 0200 	mov.w	r2, #0
  26:	70da      	strb	r2, [r3, #3]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1043
}
  28:	f107 070c 	add.w	r7, r7, #12
  2c:	46bd      	mov	sp, r7
  2e:	bc80      	pop	{r7}
  30:	4770      	bx	lr
  32:	bf00      	nop

Disassembly of section .text.RTC_GetDate:

00000000 <RTC_GetDate>:
RTC_GetDate():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1056
  * @param RTC_DateStruct: pointer to a RTC_DateTypeDef structure that will 
  *                        contain the returned current date configuration.     
  * @retval None
  */
void RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
{
   0:	b580      	push	{r7, lr}
   2:	b084      	sub	sp, #16
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	6039      	str	r1, [r7, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1057
  uint32_t tmpreg = 0;
   a:	f04f 0300 	mov.w	r3, #0
   e:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1063

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));
  
  /* Get the RTC_TR register */
  tmpreg = (uint32_t)(RTC->DR & RTC_DR_RESERVED_MASK); 
  10:	4b23      	ldr	r3, [pc, #140]	; (a0 <RTC_GetDate+0xa0>)
  12:	685b      	ldr	r3, [r3, #4]
  14:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
  18:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
  1c:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1066

  /* Fill the structure fields with the read parameters */
  RTC_DateStruct->RTC_Year = (uint8_t)((tmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
  1e:	68fb      	ldr	r3, [r7, #12]
  20:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  24:	ea4f 4313 	mov.w	r3, r3, lsr #16
  28:	b2da      	uxtb	r2, r3
  2a:	683b      	ldr	r3, [r7, #0]
  2c:	70da      	strb	r2, [r3, #3]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1067
  RTC_DateStruct->RTC_Month = (uint8_t)((tmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
  2e:	68fb      	ldr	r3, [r7, #12]
  30:	f403 53f8 	and.w	r3, r3, #7936	; 0x1f00
  34:	ea4f 2313 	mov.w	r3, r3, lsr #8
  38:	b2da      	uxtb	r2, r3
  3a:	683b      	ldr	r3, [r7, #0]
  3c:	705a      	strb	r2, [r3, #1]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1068
  RTC_DateStruct->RTC_Date = (uint8_t)(tmpreg & (RTC_DR_DT | RTC_DR_DU));
  3e:	68fb      	ldr	r3, [r7, #12]
  40:	b2db      	uxtb	r3, r3
  42:	f003 033f 	and.w	r3, r3, #63	; 0x3f
  46:	b2da      	uxtb	r2, r3
  48:	683b      	ldr	r3, [r7, #0]
  4a:	709a      	strb	r2, [r3, #2]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1069
  RTC_DateStruct->RTC_WeekDay = (uint8_t)((tmpreg & (RTC_DR_WDU)) >> 13);
  4c:	68fb      	ldr	r3, [r7, #12]
  4e:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
  52:	ea4f 3353 	mov.w	r3, r3, lsr #13
  56:	b2da      	uxtb	r2, r3
  58:	683b      	ldr	r3, [r7, #0]
  5a:	701a      	strb	r2, [r3, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1072

  /* Check the input parameters format */
  if (RTC_Format == RTC_Format_BIN)
  5c:	687b      	ldr	r3, [r7, #4]
  5e:	2b00      	cmp	r3, #0
  60:	d11a      	bne.n	98 <RTC_GetDate+0x98>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1075
  {
    /* Convert the structure parameters to Binary format */
    RTC_DateStruct->RTC_Year = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year);
  62:	683b      	ldr	r3, [r7, #0]
  64:	78db      	ldrb	r3, [r3, #3]
  66:	4618      	mov	r0, r3
  68:	f7ff fffe 	bl	0 <RTC_GetDate>
  6c:	4603      	mov	r3, r0
  6e:	461a      	mov	r2, r3
  70:	683b      	ldr	r3, [r7, #0]
  72:	70da      	strb	r2, [r3, #3]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1076
    RTC_DateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
  74:	683b      	ldr	r3, [r7, #0]
  76:	785b      	ldrb	r3, [r3, #1]
  78:	4618      	mov	r0, r3
  7a:	f7ff fffe 	bl	0 <RTC_GetDate>
  7e:	4603      	mov	r3, r0
  80:	461a      	mov	r2, r3
  82:	683b      	ldr	r3, [r7, #0]
  84:	705a      	strb	r2, [r3, #1]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1077
    RTC_DateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
  86:	683b      	ldr	r3, [r7, #0]
  88:	789b      	ldrb	r3, [r3, #2]
  8a:	4618      	mov	r0, r3
  8c:	f7ff fffe 	bl	0 <RTC_GetDate>
  90:	4603      	mov	r3, r0
  92:	461a      	mov	r2, r3
  94:	683b      	ldr	r3, [r7, #0]
  96:	709a      	strb	r2, [r3, #2]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1079
  }
}
  98:	f107 0710 	add.w	r7, r7, #16
  9c:	46bd      	mov	sp, r7
  9e:	bd80      	pop	{r7, pc}
  a0:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_SetAlarm:

00000000 <RTC_SetAlarm>:
RTC_SetAlarm():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1116
  * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that 
  *                          contains the alarm configuration parameters.     
  * @retval None
  */
void RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
{
   0:	b590      	push	{r4, r7, lr}
   2:	b087      	sub	sp, #28
   4:	af00      	add	r7, sp, #0
   6:	60f8      	str	r0, [r7, #12]
   8:	60b9      	str	r1, [r7, #8]
   a:	607a      	str	r2, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1117
  uint32_t tmpreg = 0;
   c:	f04f 0300 	mov.w	r3, #0
  10:	617b      	str	r3, [r7, #20]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1125
  assert_param(IS_RTC_FORMAT(RTC_Format));
  assert_param(IS_RTC_ALARM(RTC_Alarm));
  assert_param(IS_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
  assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));

  if (RTC_Format == RTC_Format_BIN)
  12:	68fb      	ldr	r3, [r7, #12]
  14:	2b00      	cmp	r3, #0
  16:	d10a      	bne.n	2e <RTC_SetAlarm+0x2e>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1127
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
  18:	4b4e      	ldr	r3, [pc, #312]	; (154 <RTC_SetAlarm+0x154>)
  1a:	689b      	ldr	r3, [r3, #8]
  1c:	f003 0340 	and.w	r3, r3, #64	; 0x40
  20:	2b00      	cmp	r3, #0
  22:	d129      	bne.n	78 <RTC_SetAlarm+0x78>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1134
      assert_param(IS_RTC_HOUR12(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
      assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
    } 
    else
    {
      RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
  24:	687b      	ldr	r3, [r7, #4]
  26:	f04f 0200 	mov.w	r2, #0
  2a:	70da      	strb	r2, [r3, #3]
  2c:	e024      	b.n	78 <RTC_SetAlarm+0x78>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1151
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
    }
  }
  else
  {
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
  2e:	4b49      	ldr	r3, [pc, #292]	; (154 <RTC_SetAlarm+0x154>)
  30:	689b      	ldr	r3, [r3, #8]
  32:	f003 0340 	and.w	r3, r3, #64	; 0x40
  36:	2b00      	cmp	r3, #0
  38:	d007      	beq.n	4a <RTC_SetAlarm+0x4a>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1153
    {
      tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours);
  3a:	687b      	ldr	r3, [r7, #4]
  3c:	781b      	ldrb	r3, [r3, #0]
  3e:	4618      	mov	r0, r3
  40:	f7ff fffe 	bl	0 <RTC_SetAlarm>
  44:	4603      	mov	r3, r0
  46:	617b      	str	r3, [r7, #20]
  48:	e003      	b.n	52 <RTC_SetAlarm+0x52>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1159
      assert_param(IS_RTC_HOUR12(tmpreg));
      assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
    } 
    else
    {
      RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
  4a:	687b      	ldr	r3, [r7, #4]
  4c:	f04f 0200 	mov.w	r2, #0
  50:	70da      	strb	r2, [r3, #3]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1166
    }
    
    assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes)));
    assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)));
    
    if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
  52:	687b      	ldr	r3, [r7, #4]
  54:	689b      	ldr	r3, [r3, #8]
  56:	2b00      	cmp	r3, #0
  58:	d107      	bne.n	6a <RTC_SetAlarm+0x6a>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1168
    {
      tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
  5a:	687b      	ldr	r3, [r7, #4]
  5c:	7b1b      	ldrb	r3, [r3, #12]
  5e:	4618      	mov	r0, r3
  60:	f7ff fffe 	bl	0 <RTC_SetAlarm>
  64:	4603      	mov	r3, r0
  66:	617b      	str	r3, [r7, #20]
  68:	e006      	b.n	78 <RTC_SetAlarm+0x78>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1173
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(tmpreg));    
    }
    else
    {
      tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
  6a:	687b      	ldr	r3, [r7, #4]
  6c:	7b1b      	ldrb	r3, [r3, #12]
  6e:	4618      	mov	r0, r3
  70:	f7ff fffe 	bl	0 <RTC_SetAlarm>
  74:	4603      	mov	r3, r0
  76:	617b      	str	r3, [r7, #20]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1179
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));      
    }    
  }

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  78:	68fb      	ldr	r3, [r7, #12]
  7a:	2b00      	cmp	r3, #0
  7c:	d01e      	beq.n	bc <RTC_SetAlarm+0xbc>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1181
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
  7e:	687b      	ldr	r3, [r7, #4]
  80:	781b      	ldrb	r3, [r3, #0]
  82:	ea4f 4203 	mov.w	r2, r3, lsl #16
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1182
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
  86:	687b      	ldr	r3, [r7, #4]
  88:	785b      	ldrb	r3, [r3, #1]
  8a:	ea4f 2303 	mov.w	r3, r3, lsl #8
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1181
  }

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
  8e:	431a      	orrs	r2, r3
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1183
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
  90:	687b      	ldr	r3, [r7, #4]
  92:	789b      	ldrb	r3, [r3, #2]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1182

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
  94:	431a      	orrs	r2, r3
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1184
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
  96:	687b      	ldr	r3, [r7, #4]
  98:	78db      	ldrb	r3, [r3, #3]
  9a:	ea4f 4303 	mov.w	r3, r3, lsl #16
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1183
  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
  9e:	431a      	orrs	r2, r3
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1185
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
  a0:	687b      	ldr	r3, [r7, #4]
  a2:	7b1b      	ldrb	r3, [r3, #12]
  a4:	ea4f 6303 	mov.w	r3, r3, lsl #24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1184
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
  a8:	431a      	orrs	r2, r3
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1186
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
  aa:	687b      	ldr	r3, [r7, #4]
  ac:	689b      	ldr	r3, [r3, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1185
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
  ae:	431a      	orrs	r2, r3
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1187
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  b0:	687b      	ldr	r3, [r7, #4]
  b2:	685b      	ldr	r3, [r3, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1181
  }

  /* Check the input parameters format */
  if (RTC_Format != RTC_Format_BIN)
  {
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
  b4:	ea42 0303 	orr.w	r3, r2, r3
  b8:	617b      	str	r3, [r7, #20]
  ba:	e030      	b.n	11e <RTC_SetAlarm+0x11e>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1191
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
  bc:	687b      	ldr	r3, [r7, #4]
  be:	781b      	ldrb	r3, [r3, #0]
  c0:	4618      	mov	r0, r3
  c2:	f7ff fffe 	bl	0 <RTC_SetAlarm>
  c6:	4603      	mov	r3, r0
  c8:	ea4f 4403 	mov.w	r4, r3, lsl #16
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1192
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
  cc:	687b      	ldr	r3, [r7, #4]
  ce:	785b      	ldrb	r3, [r3, #1]
  d0:	4618      	mov	r0, r3
  d2:	f7ff fffe 	bl	0 <RTC_SetAlarm>
  d6:	4603      	mov	r3, r0
  d8:	ea4f 2303 	mov.w	r3, r3, lsl #8
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1191
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
  dc:	431c      	orrs	r4, r3
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1193
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
  de:	687b      	ldr	r3, [r7, #4]
  e0:	789b      	ldrb	r3, [r3, #2]
  e2:	4618      	mov	r0, r3
  e4:	f7ff fffe 	bl	0 <RTC_SetAlarm>
  e8:	4603      	mov	r3, r0
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1192
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
  ea:	ea44 0203 	orr.w	r2, r4, r3
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1194
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
  ee:	687b      	ldr	r3, [r7, #4]
  f0:	78db      	ldrb	r3, [r3, #3]
  f2:	ea4f 4303 	mov.w	r3, r3, lsl #16
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1193
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
  f6:	ea42 0403 	orr.w	r4, r2, r3
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1195
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
  fa:	687b      	ldr	r3, [r7, #4]
  fc:	7b1b      	ldrb	r3, [r3, #12]
  fe:	4618      	mov	r0, r3
 100:	f7ff fffe 	bl	0 <RTC_SetAlarm>
 104:	4603      	mov	r3, r0
 106:	ea4f 6303 	mov.w	r3, r3, lsl #24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1194
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
 10a:	ea44 0203 	orr.w	r2, r4, r3
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1196
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
 10e:	687b      	ldr	r3, [r7, #4]
 110:	689b      	ldr	r3, [r3, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1195
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 112:	431a      	orrs	r2, r3
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1197
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
 114:	687b      	ldr	r3, [r7, #4]
 116:	685b      	ldr	r3, [r3, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1191
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  }  
  else
  {
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 118:	ea42 0303 	orr.w	r3, r2, r3
 11c:	617b      	str	r3, [r7, #20]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1201
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
  } 

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
 11e:	4b0d      	ldr	r3, [pc, #52]	; (154 <RTC_SetAlarm+0x154>)
 120:	f04f 02ca 	mov.w	r2, #202	; 0xca
 124:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1202
  RTC->WPR = 0x53;
 126:	4b0b      	ldr	r3, [pc, #44]	; (154 <RTC_SetAlarm+0x154>)
 128:	f04f 0253 	mov.w	r2, #83	; 0x53
 12c:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1205

  /* Configure the Alarm register */
  if (RTC_Alarm == RTC_Alarm_A)
 12e:	68bb      	ldr	r3, [r7, #8]
 130:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 134:	d103      	bne.n	13e <RTC_SetAlarm+0x13e>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1207
  {
    RTC->ALRMAR = (uint32_t)tmpreg;
 136:	4b07      	ldr	r3, [pc, #28]	; (154 <RTC_SetAlarm+0x154>)
 138:	697a      	ldr	r2, [r7, #20]
 13a:	61da      	str	r2, [r3, #28]
 13c:	e002      	b.n	144 <RTC_SetAlarm+0x144>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1211
  }
  else
  {
    RTC->ALRMBR = (uint32_t)tmpreg;
 13e:	4b05      	ldr	r3, [pc, #20]	; (154 <RTC_SetAlarm+0x154>)
 140:	697a      	ldr	r2, [r7, #20]
 142:	621a      	str	r2, [r3, #32]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1215
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;   
 144:	4b03      	ldr	r3, [pc, #12]	; (154 <RTC_SetAlarm+0x154>)
 146:	f04f 02ff 	mov.w	r2, #255	; 0xff
 14a:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1216
}
 14c:	f107 071c 	add.w	r7, r7, #28
 150:	46bd      	mov	sp, r7
 152:	bd90      	pop	{r4, r7, pc}
 154:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_AlarmStructInit:

00000000 <RTC_AlarmStructInit>:
RTC_AlarmStructInit():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1227
  * @param  RTC_AlarmStruct: pointer to a @ref RTC_AlarmTypeDef structure which
  *         will be initialized.
  * @retval None
  */
void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1229
  /* Alarm Time Settings : Time = 00h:00mn:00sec */
  RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
   8:	687b      	ldr	r3, [r7, #4]
   a:	f04f 0200 	mov.w	r2, #0
   e:	70da      	strb	r2, [r3, #3]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1230
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = 0;
  10:	687b      	ldr	r3, [r7, #4]
  12:	f04f 0200 	mov.w	r2, #0
  16:	701a      	strb	r2, [r3, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1231
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
  18:	687b      	ldr	r3, [r7, #4]
  1a:	f04f 0200 	mov.w	r2, #0
  1e:	705a      	strb	r2, [r3, #1]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1232
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;
  20:	687b      	ldr	r3, [r7, #4]
  22:	f04f 0200 	mov.w	r2, #0
  26:	709a      	strb	r2, [r3, #2]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1235

  /* Alarm Date Settings : Date = 1st day of the month */
  RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
  28:	687b      	ldr	r3, [r7, #4]
  2a:	f04f 0200 	mov.w	r2, #0
  2e:	609a      	str	r2, [r3, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1236
  RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
  30:	687b      	ldr	r3, [r7, #4]
  32:	f04f 0201 	mov.w	r2, #1
  36:	731a      	strb	r2, [r3, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1239

  /* Alarm Masks Settings : Mask =  all fields are not masked */
  RTC_AlarmStruct->RTC_AlarmMask = RTC_AlarmMask_None;
  38:	687b      	ldr	r3, [r7, #4]
  3a:	f04f 0200 	mov.w	r2, #0
  3e:	605a      	str	r2, [r3, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1240
}
  40:	f107 070c 	add.w	r7, r7, #12
  44:	46bd      	mov	sp, r7
  46:	bc80      	pop	{r7}
  48:	4770      	bx	lr
  4a:	bf00      	nop

Disassembly of section .text.RTC_GetAlarm:

00000000 <RTC_GetAlarm>:
RTC_GetAlarm():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1257
  * @param  RTC_AlarmStruct: pointer to a RTC_AlarmTypeDef structure that will 
  *                          contains the output alarm configuration values.     
  * @retval None
  */
void RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
{
   0:	b580      	push	{r7, lr}
   2:	b086      	sub	sp, #24
   4:	af00      	add	r7, sp, #0
   6:	60f8      	str	r0, [r7, #12]
   8:	60b9      	str	r1, [r7, #8]
   a:	607a      	str	r2, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1258
  uint32_t tmpreg = 0;
   c:	f04f 0300 	mov.w	r3, #0
  10:	617b      	str	r3, [r7, #20]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1265
  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));
  assert_param(IS_RTC_ALARM(RTC_Alarm)); 

  /* Get the RTC_ALRMxR register */
  if (RTC_Alarm == RTC_Alarm_A)
  12:	68bb      	ldr	r3, [r7, #8]
  14:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  18:	d103      	bne.n	22 <RTC_GetAlarm+0x22>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1267
  {
    tmpreg = (uint32_t)(RTC->ALRMAR);
  1a:	4b31      	ldr	r3, [pc, #196]	; (e0 <RTC_GetAlarm+0xe0>)
  1c:	69db      	ldr	r3, [r3, #28]
  1e:	617b      	str	r3, [r7, #20]
  20:	e002      	b.n	28 <RTC_GetAlarm+0x28>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1271
  }
  else
  {
    tmpreg = (uint32_t)(RTC->ALRMBR);
  22:	4b2f      	ldr	r3, [pc, #188]	; (e0 <RTC_GetAlarm+0xe0>)
  24:	6a1b      	ldr	r3, [r3, #32]
  26:	617b      	str	r3, [r7, #20]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1275
  }

  /* Fill the structure with the read parameters */
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | \
  28:	697b      	ldr	r3, [r7, #20]
  2a:	f403 137c 	and.w	r3, r3, #4128768	; 0x3f0000
  2e:	ea4f 4313 	mov.w	r3, r3, lsr #16
  32:	b2da      	uxtb	r2, r3
  34:	687b      	ldr	r3, [r7, #4]
  36:	701a      	strb	r2, [r3, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1277
                                                     RTC_ALRMAR_HU)) >> 16);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
  38:	697b      	ldr	r3, [r7, #20]
  3a:	f403 43fe 	and.w	r3, r3, #32512	; 0x7f00
  3e:	ea4f 2313 	mov.w	r3, r3, lsr #8
  42:	b2da      	uxtb	r2, r3
  44:	687b      	ldr	r3, [r7, #4]
  46:	705a      	strb	r2, [r3, #1]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1279
                                                     RTC_ALRMAR_MNU)) >> 8);
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
  48:	697b      	ldr	r3, [r7, #20]
  4a:	b2db      	uxtb	r3, r3
  4c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  50:	b2da      	uxtb	r2, r3
  52:	687b      	ldr	r3, [r7, #4]
  54:	709a      	strb	r2, [r3, #2]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1281
                                                     RTC_ALRMAR_SU));
  RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
  56:	697b      	ldr	r3, [r7, #20]
  58:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
  5c:	ea4f 4313 	mov.w	r3, r3, lsr #16
  60:	b2da      	uxtb	r2, r3
  62:	687b      	ldr	r3, [r7, #4]
  64:	70da      	strb	r2, [r3, #3]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1282
  RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
  66:	697b      	ldr	r3, [r7, #20]
  68:	f003 537c 	and.w	r3, r3, #1056964608	; 0x3f000000
  6c:	ea4f 6313 	mov.w	r3, r3, lsr #24
  70:	b2da      	uxtb	r2, r3
  72:	687b      	ldr	r3, [r7, #4]
  74:	731a      	strb	r2, [r3, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1283
  RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
  76:	697b      	ldr	r3, [r7, #20]
  78:	f003 4280 	and.w	r2, r3, #1073741824	; 0x40000000
  7c:	687b      	ldr	r3, [r7, #4]
  7e:	609a      	str	r2, [r3, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1284
  RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);
  80:	697b      	ldr	r3, [r7, #20]
  82:	f003 3280 	and.w	r2, r3, #2155905152	; 0x80808080
  86:	687b      	ldr	r3, [r7, #4]
  88:	605a      	str	r2, [r3, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1286

  if (RTC_Format == RTC_Format_BIN)
  8a:	68fb      	ldr	r3, [r7, #12]
  8c:	2b00      	cmp	r3, #0
  8e:	d123      	bne.n	d8 <RTC_GetAlarm+0xd8>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1288
  {
    RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
  90:	687b      	ldr	r3, [r7, #4]
  92:	781b      	ldrb	r3, [r3, #0]
  94:	4618      	mov	r0, r3
  96:	f7ff fffe 	bl	0 <RTC_GetAlarm>
  9a:	4603      	mov	r3, r0
  9c:	461a      	mov	r2, r3
  9e:	687b      	ldr	r3, [r7, #4]
  a0:	701a      	strb	r2, [r3, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1290
                                                        RTC_AlarmTime.RTC_Hours);
    RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
  a2:	687b      	ldr	r3, [r7, #4]
  a4:	785b      	ldrb	r3, [r3, #1]
  a6:	4618      	mov	r0, r3
  a8:	f7ff fffe 	bl	0 <RTC_GetAlarm>
  ac:	4603      	mov	r3, r0
  ae:	461a      	mov	r2, r3
  b0:	687b      	ldr	r3, [r7, #4]
  b2:	705a      	strb	r2, [r3, #1]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1292
                                                        RTC_AlarmTime.RTC_Minutes);
    RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
  b4:	687b      	ldr	r3, [r7, #4]
  b6:	789b      	ldrb	r3, [r3, #2]
  b8:	4618      	mov	r0, r3
  ba:	f7ff fffe 	bl	0 <RTC_GetAlarm>
  be:	4603      	mov	r3, r0
  c0:	461a      	mov	r2, r3
  c2:	687b      	ldr	r3, [r7, #4]
  c4:	709a      	strb	r2, [r3, #2]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1294
                                                        RTC_AlarmTime.RTC_Seconds);
    RTC_AlarmStruct->RTC_AlarmDateWeekDay = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
  c6:	687b      	ldr	r3, [r7, #4]
  c8:	7b1b      	ldrb	r3, [r3, #12]
  ca:	4618      	mov	r0, r3
  cc:	f7ff fffe 	bl	0 <RTC_GetAlarm>
  d0:	4603      	mov	r3, r0
  d2:	461a      	mov	r2, r3
  d4:	687b      	ldr	r3, [r7, #4]
  d6:	731a      	strb	r2, [r3, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1296
  }  
}
  d8:	f107 0718 	add.w	r7, r7, #24
  dc:	46bd      	mov	sp, r7
  de:	bd80      	pop	{r7, pc}
  e0:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_AlarmCmd:

00000000 <RTC_AlarmCmd>:
RTC_AlarmCmd():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1311
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Alarm is enabled/disabled
  *          - ERROR: RTC Alarm is not enabled/disabled  
  */
ErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState)
{
   0:	b087b480 	.word	0xb087b480
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	70fb      	strb	r3, [r7, #3]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1312
  __IO uint32_t alarmcounter = 0x00;
   c:	f04f 0300 	mov.w	r3, #0
  10:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1313
  uint32_t alarmstatus = 0x00;
  12:	f04f 0300 	mov.w	r3, #0
  16:	613b      	str	r3, [r7, #16]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1314
  ErrorStatus status = ERROR;
  18:	f04f 0300 	mov.w	r3, #0
  1c:	75fb      	strb	r3, [r7, #23]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1321
  /* Check the parameters */
  assert_param(IS_RTC_CMD_ALARM(RTC_Alarm));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  1e:	4b26      	ldr	r3, [pc, #152]	; (b8 <RTC_AlarmCmd+0xb8>)
  20:	f04f 02ca 	mov.w	r2, #202	; 0xca
  24:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1322
  RTC->WPR = 0x53;
  26:	4b24      	ldr	r3, [pc, #144]	; (b8 <RTC_AlarmCmd+0xb8>)
  28:	f04f 0253 	mov.w	r2, #83	; 0x53
  2c:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1325

  /* Configure the Alarm state */
  if (NewState != DISABLE)
  2e:	78fb      	ldrb	r3, [r7, #3]
  30:	2b00      	cmp	r3, #0
  32:	d00a      	beq.n	4a <RTC_AlarmCmd+0x4a>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1327
  {
    RTC->CR |= (uint32_t)RTC_Alarm;
  34:	4b20      	ldr	r3, [pc, #128]	; (b8 <RTC_AlarmCmd+0xb8>)
  36:	4a20      	ldr	r2, [pc, #128]	; (b8 <RTC_AlarmCmd+0xb8>)
  38:	6891      	ldr	r1, [r2, #8]
  3a:	687a      	ldr	r2, [r7, #4]
  3c:	ea41 0202 	orr.w	r2, r1, r2
  40:	609a      	str	r2, [r3, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1329

    status = SUCCESS;    
  42:	f04f 0301 	mov.w	r3, #1
  46:	75fb      	strb	r3, [r7, #23]
  48:	e02b      	b.n	a2 <RTC_AlarmCmd+0xa2>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1334
  }
  else
  { 
    /* Disable the Alarm in RTC_CR register */
    RTC->CR &= (uint32_t)~RTC_Alarm;
  4a:	4b1b      	ldr	r3, [pc, #108]	; (b8 <RTC_AlarmCmd+0xb8>)
  4c:	4a1a      	ldr	r2, [pc, #104]	; (b8 <RTC_AlarmCmd+0xb8>)
  4e:	6891      	ldr	r1, [r2, #8]
  50:	687a      	ldr	r2, [r7, #4]
  52:	ea6f 0202 	mvn.w	r2, r2
  56:	ea01 0202 	and.w	r2, r1, r2
  5a:	609a      	str	r2, [r3, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1339
   
    /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
    do
    {
      alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
  5c:	4b16      	ldr	r3, [pc, #88]	; (b8 <RTC_AlarmCmd+0xb8>)
  5e:	68da      	ldr	r2, [r3, #12]
  60:	687b      	ldr	r3, [r7, #4]
  62:	ea4f 2313 	mov.w	r3, r3, lsr #8
  66:	ea02 0303 	and.w	r3, r2, r3
  6a:	613b      	str	r3, [r7, #16]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1340
      alarmcounter++;  
  6c:	68fb      	ldr	r3, [r7, #12]
  6e:	f103 0301 	add.w	r3, r3, #1
  72:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1341
    } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
  74:	68fb      	ldr	r3, [r7, #12]
  76:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
  7a:	d002      	beq.n	82 <RTC_AlarmCmd+0x82>
  7c:	693b      	ldr	r3, [r7, #16]
  7e:	2b00      	cmp	r3, #0
  80:	d0ec      	beq.n	5c <RTC_AlarmCmd+0x5c>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1343
    
    if ((RTC->ISR & (RTC_Alarm >> 8)) == RESET)
  82:	4b0d      	ldr	r3, [pc, #52]	; (b8 <RTC_AlarmCmd+0xb8>)
  84:	68da      	ldr	r2, [r3, #12]
  86:	687b      	ldr	r3, [r7, #4]
  88:	ea4f 2313 	mov.w	r3, r3, lsr #8
  8c:	ea02 0303 	and.w	r3, r2, r3
  90:	2b00      	cmp	r3, #0
  92:	d103      	bne.n	9c <RTC_AlarmCmd+0x9c>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1345
    {
      status = ERROR;
  94:	f04f 0300 	mov.w	r3, #0
  98:	75fb      	strb	r3, [r7, #23]
  9a:	e002      	b.n	a2 <RTC_AlarmCmd+0xa2>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1349
    } 
    else
    {
      status = SUCCESS;
  9c:	f04f 0301 	mov.w	r3, #1
  a0:	75fb      	strb	r3, [r7, #23]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1354
    }        
  } 

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
  a2:	4b05      	ldr	r3, [pc, #20]	; (b8 <RTC_AlarmCmd+0xb8>)
  a4:	f04f 02ff 	mov.w	r2, #255	; 0xff
  a8:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1356
  
  return status;
  aa:	7dfb      	ldrb	r3, [r7, #23]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1357
}
  ac:	4618      	mov	r0, r3
  ae:	f107 071c 	add.w	r7, r7, #28
  b2:	46bd      	mov	sp, r7
  b4:	bc80      	pop	{r7}
  b6:	4770      	bx	lr
  b8:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_AlarmSubSecondConfig:

00000000 <RTC_AlarmSubSecondConfig>:
RTC_AlarmSubSecondConfig():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1405
  *     @arg RTC_AlarmSubSecondMask_None   : SS[14:0] are compared and must match
  *                                          to activate alarm
  * @retval None
  */
void RTC_AlarmSubSecondConfig(uint32_t RTC_Alarm, uint32_t RTC_AlarmSubSecondValue, uint32_t RTC_AlarmSubSecondMask)
{
   0:	b087b480 	.word	0xb087b480
   4:	af00      	add	r7, sp, #0
   6:	60f8      	str	r0, [r7, #12]
   8:	60b9      	str	r1, [r7, #8]
   a:	607a      	str	r2, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1406
  uint32_t tmpreg = 0;
   c:	f04f 0300 	mov.w	r3, #0
  10:	617b      	str	r3, [r7, #20]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1414
  assert_param(IS_RTC_ALARM(RTC_Alarm));
  assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(RTC_AlarmSubSecondValue));
  assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(RTC_AlarmSubSecondMask));
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  12:	4b10      	ldr	r3, [pc, #64]	; (54 <RTC_AlarmSubSecondConfig+0x54>)
  14:	f04f 02ca 	mov.w	r2, #202	; 0xca
  18:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1415
  RTC->WPR = 0x53;
  1a:	4b0e      	ldr	r3, [pc, #56]	; (54 <RTC_AlarmSubSecondConfig+0x54>)
  1c:	f04f 0253 	mov.w	r2, #83	; 0x53
  20:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1418
  
  /* Configure the Alarm A or Alarm B Sub Second registers */
  tmpreg = (uint32_t) (uint32_t)(RTC_AlarmSubSecondValue) | (uint32_t)(RTC_AlarmSubSecondMask);
  22:	68ba      	ldr	r2, [r7, #8]
  24:	687b      	ldr	r3, [r7, #4]
  26:	ea42 0303 	orr.w	r3, r2, r3
  2a:	617b      	str	r3, [r7, #20]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1420
  
  if (RTC_Alarm == RTC_Alarm_A)
  2c:	68fb      	ldr	r3, [r7, #12]
  2e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  32:	d103      	bne.n	3c <RTC_AlarmSubSecondConfig+0x3c>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1423
  {
    /* Configure the Alarm A Sub Second register */
    RTC->ALRMASSR = tmpreg;
  34:	4b07      	ldr	r3, [pc, #28]	; (54 <RTC_AlarmSubSecondConfig+0x54>)
  36:	697a      	ldr	r2, [r7, #20]
  38:	645a      	str	r2, [r3, #68]	; 0x44
  3a:	e002      	b.n	42 <RTC_AlarmSubSecondConfig+0x42>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1428
  }
  else
  {
    /* Configure the Alarm B Sub Second register */
    RTC->ALRMBSSR = tmpreg;
  3c:	4b05      	ldr	r3, [pc, #20]	; (54 <RTC_AlarmSubSecondConfig+0x54>)
  3e:	697a      	ldr	r2, [r7, #20]
  40:	649a      	str	r2, [r3, #72]	; 0x48
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1432
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
  42:	4b04      	ldr	r3, [pc, #16]	; (54 <RTC_AlarmSubSecondConfig+0x54>)
  44:	f04f 02ff 	mov.w	r2, #255	; 0xff
  48:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1434

}
  4a:	f107 071c 	add.w	r7, r7, #28
  4e:	46bd      	mov	sp, r7
  50:	bc80      	pop	{r7}
  52:	4770      	bx	lr
  54:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_GetAlarmSubSecond:

00000000 <RTC_GetAlarmSubSecond>:
RTC_GetAlarmSubSecond():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1446
  *     @arg RTC_Alarm_B: to select Alarm B
  * @param  None
  * @retval RTC Alarm Sub seconds value.
  */
uint32_t RTC_GetAlarmSubSecond(uint32_t RTC_Alarm)
{
   0:	b085b480 	.word	0xb085b480
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1447
  uint32_t tmpreg = 0;
   8:	f04f 0300 	mov.w	r3, #0
   c:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1450
  
  /* Get the RTC_ALRMxR register */
  if (RTC_Alarm == RTC_Alarm_A)
   e:	687b      	ldr	r3, [r7, #4]
  10:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  14:	d107      	bne.n	26 <RTC_GetAlarmSubSecond+0x26>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1452
  {
    tmpreg = (uint32_t)((RTC->ALRMASSR) & RTC_ALRMASSR_SS);
  16:	4b0b      	ldr	r3, [pc, #44]	; (44 <RTC_GetAlarmSubSecond+0x44>)
  18:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  1a:	ea4f 4343 	mov.w	r3, r3, lsl #17
  1e:	ea4f 4353 	mov.w	r3, r3, lsr #17
  22:	60fb      	str	r3, [r7, #12]
  24:	e006      	b.n	34 <RTC_GetAlarmSubSecond+0x34>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1456
  }
  else
  {
    tmpreg = (uint32_t)((RTC->ALRMBSSR) & RTC_ALRMBSSR_SS);
  26:	4b07      	ldr	r3, [pc, #28]	; (44 <RTC_GetAlarmSubSecond+0x44>)
  28:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  2a:	ea4f 4343 	mov.w	r3, r3, lsl #17
  2e:	ea4f 4353 	mov.w	r3, r3, lsr #17
  32:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1459
  } 
  
  return (tmpreg);
  34:	68fb      	ldr	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1460
}
  36:	4618      	mov	r0, r3
  38:	f107 0714 	add.w	r7, r7, #20
  3c:	46bd      	mov	sp, r7
  3e:	bc80      	pop	{r7}
  40:	4770      	bx	lr
  42:	bf00      	nop
  44:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_WakeUpClockConfig:

00000000 <RTC_WakeUpClockConfig>:
RTC_WakeUpClockConfig():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1495
  *            @arg RTC_WakeUpClock_CK_SPRE_16bits: RTC Wakeup Counter Clock = CK_SPRE
  *            @arg RTC_WakeUpClock_CK_SPRE_17bits: RTC Wakeup Counter Clock = CK_SPRE
  * @retval None
  */
void RTC_WakeUpClockConfig(uint32_t RTC_WakeUpClock)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1500
  /* Check the parameters */
  assert_param(IS_RTC_WAKEUP_CLOCK(RTC_WakeUpClock));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
   8:	4b0e      	ldr	r3, [pc, #56]	; (44 <RTC_WakeUpClockConfig+0x44>)
   a:	f04f 02ca 	mov.w	r2, #202	; 0xca
   e:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1501
  RTC->WPR = 0x53;
  10:	4b0c      	ldr	r3, [pc, #48]	; (44 <RTC_WakeUpClockConfig+0x44>)
  12:	f04f 0253 	mov.w	r2, #83	; 0x53
  16:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1504

  /* Clear the Wakeup Timer clock source bits in CR register */
  RTC->CR &= (uint32_t)~RTC_CR_WUCKSEL;
  18:	4b0a      	ldr	r3, [pc, #40]	; (44 <RTC_WakeUpClockConfig+0x44>)
  1a:	4a0a      	ldr	r2, [pc, #40]	; (44 <RTC_WakeUpClockConfig+0x44>)
  1c:	6892      	ldr	r2, [r2, #8]
  1e:	f022 0207 	bic.w	r2, r2, #7
  22:	609a      	str	r2, [r3, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1507

  /* Configure the clock source */
  RTC->CR |= (uint32_t)RTC_WakeUpClock;
  24:	4b07      	ldr	r3, [pc, #28]	; (44 <RTC_WakeUpClockConfig+0x44>)
  26:	4a07      	ldr	r2, [pc, #28]	; (44 <RTC_WakeUpClockConfig+0x44>)
  28:	6891      	ldr	r1, [r2, #8]
  2a:	687a      	ldr	r2, [r7, #4]
  2c:	ea41 0202 	orr.w	r2, r1, r2
  30:	609a      	str	r2, [r3, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1510
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
  32:	4b04      	ldr	r3, [pc, #16]	; (44 <RTC_WakeUpClockConfig+0x44>)
  34:	f04f 02ff 	mov.w	r2, #255	; 0xff
  38:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1511
}
  3a:	f107 070c 	add.w	r7, r7, #12
  3e:	46bd      	mov	sp, r7
  40:	bc80      	pop	{r7}
  42:	4770      	bx	lr
  44:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_SetWakeUpCounter:

00000000 <RTC_SetWakeUpCounter>:
RTC_SetWakeUpCounter():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1522
  * @param  RTC_WakeUpCounter: specifies the WakeUp counter.
  *          This parameter can be a value from 0x0000 to 0xFFFF. 
  * @retval None
  */
void RTC_SetWakeUpCounter(uint32_t RTC_WakeUpCounter)
{
   0:	b083b480 	.word	0xb083b480
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1527
  /* Check the parameters */
  assert_param(IS_RTC_WAKEUP_COUNTER(RTC_WakeUpCounter));
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
   8:	4b09      	ldr	r3, [pc, #36]	; (30 <RTC_SetWakeUpCounter+0x30>)
   a:	f04f 02ca 	mov.w	r2, #202	; 0xca
   e:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1528
  RTC->WPR = 0x53;
  10:	4b07      	ldr	r3, [pc, #28]	; (30 <RTC_SetWakeUpCounter+0x30>)
  12:	f04f 0253 	mov.w	r2, #83	; 0x53
  16:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1531
  
  /* Configure the Wakeup Timer counter */
  RTC->WUTR = (uint32_t)RTC_WakeUpCounter;
  18:	4b05      	ldr	r3, [pc, #20]	; (30 <RTC_SetWakeUpCounter+0x30>)
  1a:	687a      	ldr	r2, [r7, #4]
  1c:	615a      	str	r2, [r3, #20]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1534
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
  1e:	4b04      	ldr	r3, [pc, #16]	; (30 <RTC_SetWakeUpCounter+0x30>)
  20:	f04f 02ff 	mov.w	r2, #255	; 0xff
  24:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1535
}
  26:	f107 070c 	add.w	r7, r7, #12
  2a:	46bd      	mov	sp, r7
  2c:	bc80      	pop	{r7}
  2e:	4770      	bx	lr
  30:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_GetWakeUpCounter:

00000000 <RTC_GetWakeUpCounter>:
RTC_GetWakeUpCounter():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1543
  * @brief  Returns the RTC WakeUp timer counter value.
  * @param  None
  * @retval The RTC WakeUp Counter value.
  */
uint32_t RTC_GetWakeUpCounter(void)
{
   0:	af00b480 	.word	0xaf00b480
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1545
  /* Get the counter value */
  return ((uint32_t)(RTC->WUTR & RTC_WUTR_WUT));
   4:	4b04      	ldr	r3, [pc, #16]	; (18 <RTC_GetWakeUpCounter+0x18>)
   6:	695b      	ldr	r3, [r3, #20]
   8:	ea4f 4303 	mov.w	r3, r3, lsl #16
   c:	ea4f 4313 	mov.w	r3, r3, lsr #16
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1546
}
  10:	4618      	mov	r0, r3
  12:	46bd      	mov	sp, r7
  14:	bc80      	pop	{r7}
  16:	4770      	bx	lr
  18:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_WakeUpCmd:

00000000 <RTC_WakeUpCmd>:
RTC_WakeUpCmd():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1555
  * @param  NewState: new state of the WakeUp timer.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
ErrorStatus RTC_WakeUpCmd(FunctionalState NewState)
{
   0:	b480      	push	{r7}
   2:	b087      	sub	sp, #28
   4:	af00      	add	r7, sp, #0
   6:	4603      	mov	r3, r0
   8:	71fb      	strb	r3, [r7, #7]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1556
  __IO uint32_t wutcounter = 0x00;
   a:	f04f 0300 	mov.w	r3, #0
   e:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1557
  uint32_t wutwfstatus = 0x00;
  10:	f04f 0300 	mov.w	r3, #0
  14:	613b      	str	r3, [r7, #16]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1558
  ErrorStatus status = ERROR;
  16:	f04f 0300 	mov.w	r3, #0
  1a:	75fb      	strb	r3, [r7, #23]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1564
  
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  1c:	4b21      	ldr	r3, [pc, #132]	; (a4 <RTC_WakeUpCmd+0xa4>)
  1e:	f04f 02ca 	mov.w	r2, #202	; 0xca
  22:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1565
  RTC->WPR = 0x53;
  24:	4b1f      	ldr	r3, [pc, #124]	; (a4 <RTC_WakeUpCmd+0xa4>)
  26:	f04f 0253 	mov.w	r2, #83	; 0x53
  2a:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1567

  if (NewState != DISABLE)
  2c:	79fb      	ldrb	r3, [r7, #7]
  2e:	2b00      	cmp	r3, #0
  30:	d009      	beq.n	46 <RTC_WakeUpCmd+0x46>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1570
  {
    /* Enable the Wakeup Timer */
    RTC->CR |= (uint32_t)RTC_CR_WUTE;
  32:	4b1c      	ldr	r3, [pc, #112]	; (a4 <RTC_WakeUpCmd+0xa4>)
  34:	4a1b      	ldr	r2, [pc, #108]	; (a4 <RTC_WakeUpCmd+0xa4>)
  36:	6892      	ldr	r2, [r2, #8]
  38:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
  3c:	609a      	str	r2, [r3, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1571
    status = SUCCESS;    
  3e:	f04f 0301 	mov.w	r3, #1
  42:	75fb      	strb	r3, [r7, #23]
  44:	e022      	b.n	8c <RTC_WakeUpCmd+0x8c>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1576
  }
  else
  {
    /* Disable the Wakeup Timer */
    RTC->CR &= (uint32_t)~RTC_CR_WUTE;
  46:	4b17      	ldr	r3, [pc, #92]	; (a4 <RTC_WakeUpCmd+0xa4>)
  48:	4a16      	ldr	r2, [pc, #88]	; (a4 <RTC_WakeUpCmd+0xa4>)
  4a:	6892      	ldr	r2, [r2, #8]
  4c:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
  50:	609a      	str	r2, [r3, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1580
    /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
    do
    {
      wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
  52:	4b14      	ldr	r3, [pc, #80]	; (a4 <RTC_WakeUpCmd+0xa4>)
  54:	68db      	ldr	r3, [r3, #12]
  56:	f003 0304 	and.w	r3, r3, #4
  5a:	613b      	str	r3, [r7, #16]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1581
      wutcounter++;  
  5c:	68fb      	ldr	r3, [r7, #12]
  5e:	f103 0301 	add.w	r3, r3, #1
  62:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1582
    } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
  64:	68fb      	ldr	r3, [r7, #12]
  66:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
  6a:	d002      	beq.n	72 <RTC_WakeUpCmd+0x72>
  6c:	693b      	ldr	r3, [r7, #16]
  6e:	2b00      	cmp	r3, #0
  70:	d0ef      	beq.n	52 <RTC_WakeUpCmd+0x52>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1584
    
    if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
  72:	4b0c      	ldr	r3, [pc, #48]	; (a4 <RTC_WakeUpCmd+0xa4>)
  74:	68db      	ldr	r3, [r3, #12]
  76:	f003 0304 	and.w	r3, r3, #4
  7a:	2b00      	cmp	r3, #0
  7c:	d103      	bne.n	86 <RTC_WakeUpCmd+0x86>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1586
    {
      status = ERROR;
  7e:	f04f 0300 	mov.w	r3, #0
  82:	75fb      	strb	r3, [r7, #23]
  84:	e002      	b.n	8c <RTC_WakeUpCmd+0x8c>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1590
    }
    else
    {
      status = SUCCESS;
  86:	f04f 0301 	mov.w	r3, #1
  8a:	75fb      	strb	r3, [r7, #23]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1595
    }    
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
  8c:	4b05      	ldr	r3, [pc, #20]	; (a4 <RTC_WakeUpCmd+0xa4>)
  8e:	f04f 02ff 	mov.w	r2, #255	; 0xff
  92:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1597
  
  return status;
  94:	7dfb      	ldrb	r3, [r7, #23]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1598
}
  96:	4618      	mov	r0, r3
  98:	f107 071c 	add.w	r7, r7, #28
  9c:	46bd      	mov	sp, r7
  9e:	bc80      	pop	{r7}
  a0:	4770      	bx	lr
  a2:	bf00      	nop
  a4:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_DayLightSavingConfig:

00000000 <RTC_DayLightSavingConfig>:
RTC_DayLightSavingConfig():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1632
  *            @arg RTC_StoreOperation_Reset: BCK Bit Reset
  *            @arg RTC_StoreOperation_Set: BCK Bit Set
  * @retval None
  */
void RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation)
{
   0:	b083b480 	.word	0xb083b480
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	6039      	str	r1, [r7, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1638
  /* Check the parameters */
  assert_param(IS_RTC_DAYLIGHT_SAVING(RTC_DayLightSaving));
  assert_param(IS_RTC_STORE_OPERATION(RTC_StoreOperation));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
   a:	4b10      	ldr	r3, [pc, #64]	; (4c <RTC_DayLightSavingConfig+0x4c>)
   c:	f04f 02ca 	mov.w	r2, #202	; 0xca
  10:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1639
  RTC->WPR = 0x53;
  12:	4b0e      	ldr	r3, [pc, #56]	; (4c <RTC_DayLightSavingConfig+0x4c>)
  14:	f04f 0253 	mov.w	r2, #83	; 0x53
  18:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1642

  /* Clear the bits to be configured */
  RTC->CR &= (uint32_t)~(RTC_CR_BCK);
  1a:	4b0c      	ldr	r3, [pc, #48]	; (4c <RTC_DayLightSavingConfig+0x4c>)
  1c:	4a0b      	ldr	r2, [pc, #44]	; (4c <RTC_DayLightSavingConfig+0x4c>)
  1e:	6892      	ldr	r2, [r2, #8]
  20:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
  24:	609a      	str	r2, [r3, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1645

  /* Configure the RTC_CR register */
  RTC->CR |= (uint32_t)(RTC_DayLightSaving | RTC_StoreOperation);
  26:	4b09      	ldr	r3, [pc, #36]	; (4c <RTC_DayLightSavingConfig+0x4c>)
  28:	4a08      	ldr	r2, [pc, #32]	; (4c <RTC_DayLightSavingConfig+0x4c>)
  2a:	6891      	ldr	r1, [r2, #8]
  2c:	6878      	ldr	r0, [r7, #4]
  2e:	683a      	ldr	r2, [r7, #0]
  30:	ea40 0202 	orr.w	r2, r0, r2
  34:	ea41 0202 	orr.w	r2, r1, r2
  38:	609a      	str	r2, [r3, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1648

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
  3a:	4b04      	ldr	r3, [pc, #16]	; (4c <RTC_DayLightSavingConfig+0x4c>)
  3c:	f04f 02ff 	mov.w	r2, #255	; 0xff
  40:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1649
}
  42:	f107 070c 	add.w	r7, r7, #12
  46:	46bd      	mov	sp, r7
  48:	bc80      	pop	{r7}
  4a:	4770      	bx	lr
  4c:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_GetStoreOperation:

00000000 <RTC_GetStoreOperation>:
RTC_GetStoreOperation():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1659
  * @retval RTC Day Light Saving stored operation.
  *          - RTC_StoreOperation_Reset
  *          - RTC_StoreOperation_Set       
  */
uint32_t RTC_GetStoreOperation(void)
{
   0:	af00b480 	.word	0xaf00b480
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1660
  return (RTC->CR & RTC_CR_BCK);
   4:	4b03      	ldr	r3, [pc, #12]	; (14 <RTC_GetStoreOperation+0x14>)
   6:	689b      	ldr	r3, [r3, #8]
   8:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1661
}
   c:	4618      	mov	r0, r3
   e:	46bd      	mov	sp, r7
  10:	bc80      	pop	{r7}
  12:	4770      	bx	lr
  14:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_OutputConfig:

00000000 <RTC_OutputConfig>:
RTC_OutputConfig():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1698
  *            @arg RTC_OutputPolarity_Low: The output pin is low when the 
  *                                 ALRAF/ALRBF/WUTF is high (depending on OSEL)
  * @retval None
  */
void RTC_OutputConfig(uint32_t RTC_Output, uint32_t RTC_OutputPolarity)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	6039      	str	r1, [r7, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1704
  /* Check the parameters */
  assert_param(IS_RTC_OUTPUT(RTC_Output));
  assert_param(IS_RTC_OUTPUT_POL(RTC_OutputPolarity));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
   a:	4b10      	ldr	r3, [pc, #64]	; (4c <RTC_OutputConfig+0x4c>)
   c:	f04f 02ca 	mov.w	r2, #202	; 0xca
  10:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1705
  RTC->WPR = 0x53;
  12:	4b0e      	ldr	r3, [pc, #56]	; (4c <RTC_OutputConfig+0x4c>)
  14:	f04f 0253 	mov.w	r2, #83	; 0x53
  18:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1708

  /* Clear the bits to be configured */
  RTC->CR &= (uint32_t)~(RTC_CR_OSEL | RTC_CR_POL);
  1a:	4b0c      	ldr	r3, [pc, #48]	; (4c <RTC_OutputConfig+0x4c>)
  1c:	4a0b      	ldr	r2, [pc, #44]	; (4c <RTC_OutputConfig+0x4c>)
  1e:	6892      	ldr	r2, [r2, #8]
  20:	f422 02e0 	bic.w	r2, r2, #7340032	; 0x700000
  24:	609a      	str	r2, [r3, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1711

  /* Configure the output selection and polarity */
  RTC->CR |= (uint32_t)(RTC_Output | RTC_OutputPolarity);
  26:	4b09      	ldr	r3, [pc, #36]	; (4c <RTC_OutputConfig+0x4c>)
  28:	4a08      	ldr	r2, [pc, #32]	; (4c <RTC_OutputConfig+0x4c>)
  2a:	6891      	ldr	r1, [r2, #8]
  2c:	6878      	ldr	r0, [r7, #4]
  2e:	683a      	ldr	r2, [r7, #0]
  30:	ea40 0202 	orr.w	r2, r0, r2
  34:	ea41 0202 	orr.w	r2, r1, r2
  38:	609a      	str	r2, [r3, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1714

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
  3a:	4b04      	ldr	r3, [pc, #16]	; (4c <RTC_OutputConfig+0x4c>)
  3c:	f04f 02ff 	mov.w	r2, #255	; 0xff
  40:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1715
}
  42:	f107 070c 	add.w	r7, r7, #12
  46:	46bd      	mov	sp, r7
  48:	bc80      	pop	{r7}
  4a:	4770      	bx	lr
  4c:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_CoarseCalibConfig:

00000000 <RTC_CoarseCalibConfig>:
RTC_CoarseCalibConfig():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1752
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Coarse calibration are initialized
  *          - ERROR: RTC Coarse calibration are not initialized     
  */
ErrorStatus RTC_CoarseCalibConfig(uint32_t RTC_CalibSign, uint32_t Value)
{
   0:	b580      	push	{r7, lr}
   2:	b084      	sub	sp, #16
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	6039      	str	r1, [r7, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1753
  ErrorStatus status = ERROR;
   a:	f04f 0300 	mov.w	r3, #0
   e:	73fb      	strb	r3, [r7, #15]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1760
  /* Check the parameters */
  assert_param(IS_RTC_CALIB_SIGN(RTC_CalibSign));
  assert_param(IS_RTC_CALIB_VALUE(Value)); 

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  10:	4b12      	ldr	r3, [pc, #72]	; (5c <RTC_CoarseCalibConfig+0x5c>)
  12:	f04f 02ca 	mov.w	r2, #202	; 0xca
  16:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1761
  RTC->WPR = 0x53;
  18:	4b10      	ldr	r3, [pc, #64]	; (5c <RTC_CoarseCalibConfig+0x5c>)
  1a:	f04f 0253 	mov.w	r2, #83	; 0x53
  1e:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1764

  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
  20:	f7ff fffe 	bl	0 <RTC_CoarseCalibConfig>
  24:	4603      	mov	r3, r0
  26:	2b00      	cmp	r3, #0
  28:	d103      	bne.n	32 <RTC_CoarseCalibConfig+0x32>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1766
  {
    status = ERROR;
  2a:	f04f 0300 	mov.w	r3, #0
  2e:	73fb      	strb	r3, [r7, #15]
  30:	e00a      	b.n	48 <RTC_CoarseCalibConfig+0x48>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1771
  } 
  else
  {
    /* Set the coarse calibration value */
    RTC->CALIBR = (uint32_t)(RTC_CalibSign | Value);
  32:	4b0a      	ldr	r3, [pc, #40]	; (5c <RTC_CoarseCalibConfig+0x5c>)
  34:	6879      	ldr	r1, [r7, #4]
  36:	683a      	ldr	r2, [r7, #0]
  38:	ea41 0202 	orr.w	r2, r1, r2
  3c:	619a      	str	r2, [r3, #24]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1773
    /* Exit Initialization mode */
    RTC_ExitInitMode();
  3e:	f7ff fffe 	bl	0 <RTC_CoarseCalibConfig>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1775
    
    status = SUCCESS;
  42:	f04f 0301 	mov.w	r3, #1
  46:	73fb      	strb	r3, [r7, #15]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1779
  } 

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
  48:	4b04      	ldr	r3, [pc, #16]	; (5c <RTC_CoarseCalibConfig+0x5c>)
  4a:	f04f 02ff 	mov.w	r2, #255	; 0xff
  4e:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1781
  
  return status;
  50:	7bfb      	ldrb	r3, [r7, #15]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1782
}
  52:	4618      	mov	r0, r3
  54:	f107 0710 	add.w	r7, r7, #16
  58:	46bd      	mov	sp, r7
  5a:	bd80      	pop	{r7, pc}
  5c:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_CoarseCalibCmd:

00000000 <RTC_CoarseCalibCmd>:
RTC_CoarseCalibCmd():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1793
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Coarse calibration are enabled/disabled
  *          - ERROR: RTC Coarse calibration are not enabled/disabled    
  */
ErrorStatus RTC_CoarseCalibCmd(FunctionalState NewState)
{
   0:	b580      	push	{r7, lr}
   2:	b084      	sub	sp, #16
   4:	af00      	add	r7, sp, #0
   6:	4603      	mov	r3, r0
   8:	71fb      	strb	r3, [r7, #7]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1794
  ErrorStatus status = ERROR;
   a:	f04f 0300 	mov.w	r3, #0
   e:	73fb      	strb	r3, [r7, #15]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1800
  
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  10:	4b17      	ldr	r3, [pc, #92]	; (70 <RTC_CoarseCalibCmd+0x70>)
  12:	f04f 02ca 	mov.w	r2, #202	; 0xca
  16:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1801
  RTC->WPR = 0x53;
  18:	4b15      	ldr	r3, [pc, #84]	; (70 <RTC_CoarseCalibCmd+0x70>)
  1a:	f04f 0253 	mov.w	r2, #83	; 0x53
  1e:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1804
  
  /* Set Initialization mode */
  if (RTC_EnterInitMode() == ERROR)
  20:	f7ff fffe 	bl	0 <RTC_CoarseCalibCmd>
  24:	4603      	mov	r3, r0
  26:	2b00      	cmp	r3, #0
  28:	d103      	bne.n	32 <RTC_CoarseCalibCmd+0x32>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1806
  {
    status =  ERROR;
  2a:	f04f 0300 	mov.w	r3, #0
  2e:	73fb      	strb	r3, [r7, #15]
  30:	e014      	b.n	5c <RTC_CoarseCalibCmd+0x5c>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1810
  }
  else
  {
    if (NewState != DISABLE)
  32:	79fb      	ldrb	r3, [r7, #7]
  34:	2b00      	cmp	r3, #0
  36:	d006      	beq.n	46 <RTC_CoarseCalibCmd+0x46>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1813
    {
      /* Enable the Coarse Calibration */
      RTC->CR |= (uint32_t)RTC_CR_DCE;
  38:	4b0d      	ldr	r3, [pc, #52]	; (70 <RTC_CoarseCalibCmd+0x70>)
  3a:	4a0d      	ldr	r2, [pc, #52]	; (70 <RTC_CoarseCalibCmd+0x70>)
  3c:	6892      	ldr	r2, [r2, #8]
  3e:	f042 0280 	orr.w	r2, r2, #128	; 0x80
  42:	609a      	str	r2, [r3, #8]
  44:	e005      	b.n	52 <RTC_CoarseCalibCmd+0x52>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1818
    }
    else
    { 
      /* Disable the Coarse Calibration */
      RTC->CR &= (uint32_t)~RTC_CR_DCE;
  46:	4b0a      	ldr	r3, [pc, #40]	; (70 <RTC_CoarseCalibCmd+0x70>)
  48:	4a09      	ldr	r2, [pc, #36]	; (70 <RTC_CoarseCalibCmd+0x70>)
  4a:	6892      	ldr	r2, [r2, #8]
  4c:	f022 0280 	bic.w	r2, r2, #128	; 0x80
  50:	609a      	str	r2, [r3, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1821
    }
    /* Exit Initialization mode */
    RTC_ExitInitMode();
  52:	f7ff fffe 	bl	0 <RTC_CoarseCalibCmd>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1823
    
    status = SUCCESS;
  56:	f04f 0301 	mov.w	r3, #1
  5a:	73fb      	strb	r3, [r7, #15]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1827
  } 
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
  5c:	4b04      	ldr	r3, [pc, #16]	; (70 <RTC_CoarseCalibCmd+0x70>)
  5e:	f04f 02ff 	mov.w	r2, #255	; 0xff
  62:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1829
  
  return status;
  64:	7bfb      	ldrb	r3, [r7, #15]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1830
}
  66:	4618      	mov	r0, r3
  68:	f107 0710 	add.w	r7, r7, #16
  6c:	46bd      	mov	sp, r7
  6e:	bd80      	pop	{r7, pc}
  70:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_CalibOutputCmd:

00000000 <RTC_CalibOutputCmd>:
RTC_CalibOutputCmd():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1839
  * @param  NewState: new state of the digital calibration Output.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RTC_CalibOutputCmd(FunctionalState NewState)
{
   0:	b083b480 	.word	0xb083b480
   4:	af00      	add	r7, sp, #0
   6:	4603      	mov	r3, r0
   8:	71fb      	strb	r3, [r7, #7]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1844
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
   a:	4b10      	ldr	r3, [pc, #64]	; (4c <RTC_CalibOutputCmd+0x4c>)
   c:	f04f 02ca 	mov.w	r2, #202	; 0xca
  10:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1845
  RTC->WPR = 0x53;
  12:	4b0e      	ldr	r3, [pc, #56]	; (4c <RTC_CalibOutputCmd+0x4c>)
  14:	f04f 0253 	mov.w	r2, #83	; 0x53
  18:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1847
  
  if (NewState != DISABLE)
  1a:	79fb      	ldrb	r3, [r7, #7]
  1c:	2b00      	cmp	r3, #0
  1e:	d006      	beq.n	2e <RTC_CalibOutputCmd+0x2e>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1850
  {
    /* Enable the RTC clock output */
    RTC->CR |= (uint32_t)RTC_CR_COE;
  20:	4b0a      	ldr	r3, [pc, #40]	; (4c <RTC_CalibOutputCmd+0x4c>)
  22:	4a0a      	ldr	r2, [pc, #40]	; (4c <RTC_CalibOutputCmd+0x4c>)
  24:	6892      	ldr	r2, [r2, #8]
  26:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
  2a:	609a      	str	r2, [r3, #8]
  2c:	e005      	b.n	3a <RTC_CalibOutputCmd+0x3a>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1855
  }
  else
  { 
    /* Disable the RTC clock output */
    RTC->CR &= (uint32_t)~RTC_CR_COE;
  2e:	4b07      	ldr	r3, [pc, #28]	; (4c <RTC_CalibOutputCmd+0x4c>)
  30:	4a06      	ldr	r2, [pc, #24]	; (4c <RTC_CalibOutputCmd+0x4c>)
  32:	6892      	ldr	r2, [r2, #8]
  34:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
  38:	609a      	str	r2, [r3, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1859
  }
  
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
  3a:	4b04      	ldr	r3, [pc, #16]	; (4c <RTC_CalibOutputCmd+0x4c>)
  3c:	f04f 02ff 	mov.w	r2, #255	; 0xff
  40:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1860
}
  42:	f107 070c 	add.w	r7, r7, #12
  46:	46bd      	mov	sp, r7
  48:	bc80      	pop	{r7}
  4a:	4770      	bx	lr
  4c:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_CalibOutputConfig:

00000000 <RTC_CalibOutputConfig>:
RTC_CalibOutputConfig():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1871
  *     @arg RTC_CalibOutput_512Hz: A signal has a regular waveform at 512Hz. 
  *     @arg RTC_CalibOutput_1Hz  : A signal has a regular waveform at 1Hz.
  * @retval None
*/
void RTC_CalibOutputConfig(uint32_t RTC_CalibOutput)
{
   0:	b083b480 	.word	0xb083b480
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1876
  /* Check the parameters */
  assert_param(IS_RTC_CALIB_OUTPUT(RTC_CalibOutput));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
   8:	4b0e      	ldr	r3, [pc, #56]	; (44 <RTC_CalibOutputConfig+0x44>)
   a:	f04f 02ca 	mov.w	r2, #202	; 0xca
   e:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1877
  RTC->WPR = 0x53;
  10:	4b0c      	ldr	r3, [pc, #48]	; (44 <RTC_CalibOutputConfig+0x44>)
  12:	f04f 0253 	mov.w	r2, #83	; 0x53
  16:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1880
  
  /*clear flags before configuration */
  RTC->CR &= (uint32_t)~(RTC_CR_COSEL);
  18:	4b0a      	ldr	r3, [pc, #40]	; (44 <RTC_CalibOutputConfig+0x44>)
  1a:	4a0a      	ldr	r2, [pc, #40]	; (44 <RTC_CalibOutputConfig+0x44>)
  1c:	6892      	ldr	r2, [r2, #8]
  1e:	f422 2200 	bic.w	r2, r2, #524288	; 0x80000
  22:	609a      	str	r2, [r3, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1883

  /* Configure the RTC_CR register */
  RTC->CR |= (uint32_t)RTC_CalibOutput;
  24:	4b07      	ldr	r3, [pc, #28]	; (44 <RTC_CalibOutputConfig+0x44>)
  26:	4a07      	ldr	r2, [pc, #28]	; (44 <RTC_CalibOutputConfig+0x44>)
  28:	6891      	ldr	r1, [r2, #8]
  2a:	687a      	ldr	r2, [r7, #4]
  2c:	ea41 0202 	orr.w	r2, r1, r2
  30:	609a      	str	r2, [r3, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1886

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
  32:	4b04      	ldr	r3, [pc, #16]	; (44 <RTC_CalibOutputConfig+0x44>)
  34:	f04f 02ff 	mov.w	r2, #255	; 0xff
  38:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1887
}
  3a:	f107 070c 	add.w	r7, r7, #12
  3e:	46bd      	mov	sp, r7
  40:	bc80      	pop	{r7}
  42:	4770      	bx	lr
  44:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_SmoothCalibConfig:

00000000 <RTC_SmoothCalibConfig>:
RTC_SmoothCalibConfig():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1909
  *          - ERROR: RTC Calib registers are not configured
*/
ErrorStatus RTC_SmoothCalibConfig(uint32_t RTC_SmoothCalibPeriod,
                                  uint32_t RTC_SmoothCalibPlusPulses,
                                  uint32_t RTC_SmouthCalibMinusPulsesValue)
{
   0:	b480      	push	{r7}
   2:	b087      	sub	sp, #28
   4:	af00      	add	r7, sp, #0
   6:	60f8      	str	r0, [r7, #12]
   8:	60b9      	str	r1, [r7, #8]
   a:	607a      	str	r2, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1910
  ErrorStatus status = ERROR;
   c:	f04f 0300 	mov.w	r3, #0
  10:	75fb      	strb	r3, [r7, #23]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1911
  uint32_t recalpfcount = 0;
  12:	f04f 0300 	mov.w	r3, #0
  16:	613b      	str	r3, [r7, #16]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1919
  assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(RTC_SmoothCalibPeriod));
  assert_param(IS_RTC_SMOOTH_CALIB_PLUS(RTC_SmoothCalibPlusPulses));
  assert_param(IS_RTC_SMOOTH_CALIB_MINUS(RTC_SmouthCalibMinusPulsesValue));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  18:	4b1e      	ldr	r3, [pc, #120]	; (94 <RTC_SmoothCalibConfig+0x94>)
  1a:	f04f 02ca 	mov.w	r2, #202	; 0xca
  1e:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1920
  RTC->WPR = 0x53;
  20:	4b1c      	ldr	r3, [pc, #112]	; (94 <RTC_SmoothCalibConfig+0x94>)
  22:	f04f 0253 	mov.w	r2, #83	; 0x53
  26:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1923
  
  /* check if a calibration is pending*/
  if ((RTC->ISR & RTC_ISR_RECALPF) != RESET)
  28:	4b1a      	ldr	r3, [pc, #104]	; (94 <RTC_SmoothCalibConfig+0x94>)
  2a:	68db      	ldr	r3, [r3, #12]
  2c:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
  30:	2b00      	cmp	r3, #0
  32:	d00e      	beq.n	52 <RTC_SmoothCalibConfig+0x52>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1926
  {
    /* wait until the Calibration is completed*/
    while (((RTC->ISR & RTC_ISR_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
  34:	e003      	b.n	3e <RTC_SmoothCalibConfig+0x3e>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1928
    {
      recalpfcount++;
  36:	693b      	ldr	r3, [r7, #16]
  38:	f103 0301 	add.w	r3, r3, #1
  3c:	613b      	str	r3, [r7, #16]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1926
  
  /* check if a calibration is pending*/
  if ((RTC->ISR & RTC_ISR_RECALPF) != RESET)
  {
    /* wait until the Calibration is completed*/
    while (((RTC->ISR & RTC_ISR_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
  3e:	4b15      	ldr	r3, [pc, #84]	; (94 <RTC_SmoothCalibConfig+0x94>)
  40:	68db      	ldr	r3, [r3, #12]
  42:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
  46:	2b00      	cmp	r3, #0
  48:	d003      	beq.n	52 <RTC_SmoothCalibConfig+0x52>
  4a:	693b      	ldr	r3, [r7, #16]
  4c:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
  50:	d1f1      	bne.n	36 <RTC_SmoothCalibConfig+0x36>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1933
      recalpfcount++;
    }
  }

  /* check if the calibration pending is completed or if there is no calibration operation at all*/
  if ((RTC->ISR & RTC_ISR_RECALPF) == RESET)
  52:	4b10      	ldr	r3, [pc, #64]	; (94 <RTC_SmoothCalibConfig+0x94>)
  54:	68db      	ldr	r3, [r3, #12]
  56:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
  5a:	2b00      	cmp	r3, #0
  5c:	d10b      	bne.n	76 <RTC_SmoothCalibConfig+0x76>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1936
  {
    /* Configure the Smooth calibration settings */
    RTC->CALR = (uint32_t)((uint32_t)RTC_SmoothCalibPeriod | (uint32_t)RTC_SmoothCalibPlusPulses | (uint32_t)RTC_SmouthCalibMinusPulsesValue);
  5e:	4b0d      	ldr	r3, [pc, #52]	; (94 <RTC_SmoothCalibConfig+0x94>)
  60:	68f9      	ldr	r1, [r7, #12]
  62:	68ba      	ldr	r2, [r7, #8]
  64:	4311      	orrs	r1, r2
  66:	687a      	ldr	r2, [r7, #4]
  68:	ea41 0202 	orr.w	r2, r1, r2
  6c:	63da      	str	r2, [r3, #60]	; 0x3c
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1938

    status = SUCCESS;
  6e:	f04f 0301 	mov.w	r3, #1
  72:	75fb      	strb	r3, [r7, #23]
  74:	e002      	b.n	7c <RTC_SmoothCalibConfig+0x7c>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1942
  }
  else
  {
    status = ERROR;
  76:	f04f 0300 	mov.w	r3, #0
  7a:	75fb      	strb	r3, [r7, #23]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1946
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
  7c:	4b05      	ldr	r3, [pc, #20]	; (94 <RTC_SmoothCalibConfig+0x94>)
  7e:	f04f 02ff 	mov.w	r2, #255	; 0xff
  82:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1948
  
  return (ErrorStatus)(status);
  84:	7dfb      	ldrb	r3, [r7, #23]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1949
}
  86:	4618      	mov	r0, r3
  88:	f107 071c 	add.w	r7, r7, #28
  8c:	46bd      	mov	sp, r7
  8e:	bc80      	pop	{r7}
  90:	4770      	bx	lr
  92:	bf00      	nop
  94:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_TimeStampCmd:

00000000 <RTC_TimeStampCmd>:
RTC_TimeStampCmd():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1983
  * @param  NewState: new state of the TimeStamp.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RTC_TimeStampCmd(uint32_t RTC_TimeStampEdge, FunctionalState NewState)
{
   0:	b085b480 	.word	0xb085b480
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	70fb      	strb	r3, [r7, #3]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1984
  uint32_t tmpreg = 0;
   c:	f04f 0300 	mov.w	r3, #0
  10:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1991
  /* Check the parameters */
  assert_param(IS_RTC_TIMESTAMP_EDGE(RTC_TimeStampEdge));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Get the RTC_CR register and clear the bits to be configured */
  tmpreg = (uint32_t)(RTC->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
  12:	4b15      	ldr	r3, [pc, #84]	; (68 <RTC_TimeStampCmd+0x68>)
  14:	689b      	ldr	r3, [r3, #8]
  16:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
  1a:	f023 0308 	bic.w	r3, r3, #8
  1e:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1994

  /* Get the new configuration */
  if (NewState != DISABLE)
  20:	78fb      	ldrb	r3, [r7, #3]
  22:	2b00      	cmp	r3, #0
  24:	d007      	beq.n	36 <RTC_TimeStampCmd+0x36>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:1996
  {
    tmpreg |= (uint32_t)(RTC_TimeStampEdge | RTC_CR_TSE);
  26:	687a      	ldr	r2, [r7, #4]
  28:	68fb      	ldr	r3, [r7, #12]
  2a:	ea42 0303 	orr.w	r3, r2, r3
  2e:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
  32:	60fb      	str	r3, [r7, #12]
  34:	e004      	b.n	40 <RTC_TimeStampCmd+0x40>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2000
  }
  else
  {
    tmpreg |= (uint32_t)(RTC_TimeStampEdge);
  36:	68fa      	ldr	r2, [r7, #12]
  38:	687b      	ldr	r3, [r7, #4]
  3a:	ea42 0303 	orr.w	r3, r2, r3
  3e:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2004
  }

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  40:	4b09      	ldr	r3, [pc, #36]	; (68 <RTC_TimeStampCmd+0x68>)
  42:	f04f 02ca 	mov.w	r2, #202	; 0xca
  46:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2005
  RTC->WPR = 0x53;
  48:	4b07      	ldr	r3, [pc, #28]	; (68 <RTC_TimeStampCmd+0x68>)
  4a:	f04f 0253 	mov.w	r2, #83	; 0x53
  4e:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2008

  /* Configure the Time Stamp TSEDGE and Enable bits */
  RTC->CR = (uint32_t)tmpreg;
  50:	4b05      	ldr	r3, [pc, #20]	; (68 <RTC_TimeStampCmd+0x68>)
  52:	68fa      	ldr	r2, [r7, #12]
  54:	609a      	str	r2, [r3, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2011

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
  56:	4b04      	ldr	r3, [pc, #16]	; (68 <RTC_TimeStampCmd+0x68>)
  58:	f04f 02ff 	mov.w	r2, #255	; 0xff
  5c:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2012
}
  5e:	f107 0714 	add.w	r7, r7, #20
  62:	46bd      	mov	sp, r7
  64:	bc80      	pop	{r7}
  66:	4770      	bx	lr
  68:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_GetTimeStamp:

00000000 <RTC_GetTimeStamp>:
RTC_GetTimeStamp():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2028
  *                             contains the TimeStamp date values.     
  * @retval None
  */
void RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct, 
                                      RTC_DateTypeDef* RTC_StampDateStruct)
{
   0:	b580      	push	{r7, lr}
   2:	b086      	sub	sp, #24
   4:	af00      	add	r7, sp, #0
   6:	60f8      	str	r0, [r7, #12]
   8:	60b9      	str	r1, [r7, #8]
   a:	607a      	str	r2, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2029
  uint32_t tmptime = 0, tmpdate = 0;
   c:	f04f 0300 	mov.w	r3, #0
  10:	617b      	str	r3, [r7, #20]
  12:	f04f 0300 	mov.w	r3, #0
  16:	613b      	str	r3, [r7, #16]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2035

  /* Check the parameters */
  assert_param(IS_RTC_FORMAT(RTC_Format));

  /* Get the TimeStamp time and date registers values */
  tmptime = (uint32_t)(RTC->TSTR & RTC_TR_RESERVED_MASK);
  18:	4b41      	ldr	r3, [pc, #260]	; (120 <RTC_GetTimeStamp+0x120>)
  1a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  1c:	4b41      	ldr	r3, [pc, #260]	; (124 <RTC_GetTimeStamp+0x124>)
  1e:	ea02 0303 	and.w	r3, r2, r3
  22:	617b      	str	r3, [r7, #20]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2036
  tmpdate = (uint32_t)(RTC->TSDR & RTC_DR_RESERVED_MASK);
  24:	4b3e      	ldr	r3, [pc, #248]	; (120 <RTC_GetTimeStamp+0x120>)
  26:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  28:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
  2c:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
  30:	613b      	str	r3, [r7, #16]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2039

  /* Fill the Time structure fields with the read parameters */
  RTC_StampTimeStruct->RTC_Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
  32:	697b      	ldr	r3, [r7, #20]
  34:	f403 137c 	and.w	r3, r3, #4128768	; 0x3f0000
  38:	ea4f 4313 	mov.w	r3, r3, lsr #16
  3c:	b2da      	uxtb	r2, r3
  3e:	68bb      	ldr	r3, [r7, #8]
  40:	701a      	strb	r2, [r3, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2040
  RTC_StampTimeStruct->RTC_Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
  42:	697b      	ldr	r3, [r7, #20]
  44:	f403 43fe 	and.w	r3, r3, #32512	; 0x7f00
  48:	ea4f 2313 	mov.w	r3, r3, lsr #8
  4c:	b2da      	uxtb	r2, r3
  4e:	68bb      	ldr	r3, [r7, #8]
  50:	705a      	strb	r2, [r3, #1]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2041
  RTC_StampTimeStruct->RTC_Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
  52:	697b      	ldr	r3, [r7, #20]
  54:	b2db      	uxtb	r3, r3
  56:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  5a:	b2da      	uxtb	r2, r3
  5c:	68bb      	ldr	r3, [r7, #8]
  5e:	709a      	strb	r2, [r3, #2]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2042
  RTC_StampTimeStruct->RTC_H12 = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  
  60:	697b      	ldr	r3, [r7, #20]
  62:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
  66:	ea4f 4313 	mov.w	r3, r3, lsr #16
  6a:	b2da      	uxtb	r2, r3
  6c:	68bb      	ldr	r3, [r7, #8]
  6e:	70da      	strb	r2, [r3, #3]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2045

  /* Fill the Date structure fields with the read parameters */
  RTC_StampDateStruct->RTC_Year = 0;
  70:	687b      	ldr	r3, [r7, #4]
  72:	f04f 0200 	mov.w	r2, #0
  76:	70da      	strb	r2, [r3, #3]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2046
  RTC_StampDateStruct->RTC_Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
  78:	693b      	ldr	r3, [r7, #16]
  7a:	f403 53f8 	and.w	r3, r3, #7936	; 0x1f00
  7e:	ea4f 2313 	mov.w	r3, r3, lsr #8
  82:	b2da      	uxtb	r2, r3
  84:	687b      	ldr	r3, [r7, #4]
  86:	705a      	strb	r2, [r3, #1]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2047
  RTC_StampDateStruct->RTC_Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
  88:	693b      	ldr	r3, [r7, #16]
  8a:	b2db      	uxtb	r3, r3
  8c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
  90:	b2da      	uxtb	r2, r3
  92:	687b      	ldr	r3, [r7, #4]
  94:	709a      	strb	r2, [r3, #2]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2048
  RTC_StampDateStruct->RTC_WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
  96:	693b      	ldr	r3, [r7, #16]
  98:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
  9c:	ea4f 3353 	mov.w	r3, r3, lsr #13
  a0:	b2da      	uxtb	r2, r3
  a2:	687b      	ldr	r3, [r7, #4]
  a4:	701a      	strb	r2, [r3, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2051

  /* Check the input parameters format */
  if (RTC_Format == RTC_Format_BIN)
  a6:	68fb      	ldr	r3, [r7, #12]
  a8:	2b00      	cmp	r3, #0
  aa:	d135      	bne.n	118 <RTC_GetTimeStamp+0x118>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2054
  {
    /* Convert the Time structure parameters to Binary format */
    RTC_StampTimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Hours);
  ac:	68bb      	ldr	r3, [r7, #8]
  ae:	781b      	ldrb	r3, [r3, #0]
  b0:	4618      	mov	r0, r3
  b2:	f7ff fffe 	bl	0 <RTC_GetTimeStamp>
  b6:	4603      	mov	r3, r0
  b8:	461a      	mov	r2, r3
  ba:	68bb      	ldr	r3, [r7, #8]
  bc:	701a      	strb	r2, [r3, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2055
    RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
  be:	68bb      	ldr	r3, [r7, #8]
  c0:	785b      	ldrb	r3, [r3, #1]
  c2:	4618      	mov	r0, r3
  c4:	f7ff fffe 	bl	0 <RTC_GetTimeStamp>
  c8:	4603      	mov	r3, r0
  ca:	461a      	mov	r2, r3
  cc:	68bb      	ldr	r3, [r7, #8]
  ce:	705a      	strb	r2, [r3, #1]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2056
    RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);
  d0:	68bb      	ldr	r3, [r7, #8]
  d2:	789b      	ldrb	r3, [r3, #2]
  d4:	4618      	mov	r0, r3
  d6:	f7ff fffe 	bl	0 <RTC_GetTimeStamp>
  da:	4603      	mov	r3, r0
  dc:	461a      	mov	r2, r3
  de:	68bb      	ldr	r3, [r7, #8]
  e0:	709a      	strb	r2, [r3, #2]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2059

    /* Convert the Date structure parameters to Binary format */
    RTC_StampDateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Month);
  e2:	687b      	ldr	r3, [r7, #4]
  e4:	785b      	ldrb	r3, [r3, #1]
  e6:	4618      	mov	r0, r3
  e8:	f7ff fffe 	bl	0 <RTC_GetTimeStamp>
  ec:	4603      	mov	r3, r0
  ee:	461a      	mov	r2, r3
  f0:	687b      	ldr	r3, [r7, #4]
  f2:	705a      	strb	r2, [r3, #1]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2060
    RTC_StampDateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Date);
  f4:	687b      	ldr	r3, [r7, #4]
  f6:	789b      	ldrb	r3, [r3, #2]
  f8:	4618      	mov	r0, r3
  fa:	f7ff fffe 	bl	0 <RTC_GetTimeStamp>
  fe:	4603      	mov	r3, r0
 100:	461a      	mov	r2, r3
 102:	687b      	ldr	r3, [r7, #4]
 104:	709a      	strb	r2, [r3, #2]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2061
    RTC_StampDateStruct->RTC_WeekDay = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_WeekDay);
 106:	687b      	ldr	r3, [r7, #4]
 108:	781b      	ldrb	r3, [r3, #0]
 10a:	4618      	mov	r0, r3
 10c:	f7ff fffe 	bl	0 <RTC_GetTimeStamp>
 110:	4603      	mov	r3, r0
 112:	461a      	mov	r2, r3
 114:	687b      	ldr	r3, [r7, #4]
 116:	701a      	strb	r2, [r3, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2063
  }
}
 118:	f107 0718 	add.w	r7, r7, #24
 11c:	46bd      	mov	sp, r7
 11e:	bd80      	pop	{r7, pc}
 120:	40002800 	.word	0x40002800
 124:	007f7f7f 	.word	0x007f7f7f

Disassembly of section .text.RTC_GetTimeStampSubSecond:

00000000 <RTC_GetTimeStampSubSecond>:
RTC_GetTimeStampSubSecond():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2071
  * @brief  Get the RTC timestamp Sub seconds value.
  * @param  None
  * @retval RTC current timestamp Sub seconds value.
  */
uint32_t RTC_GetTimeStampSubSecond(void)
{
   0:	af00b480 	.word	0xaf00b480
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2073
  /* Get timestamp sub seconds values from the correspondent registers */
  return (uint32_t)(RTC->TSSSR);
   4:	4b02      	ldr	r3, [pc, #8]	; (10 <RTC_GetTimeStampSubSecond+0x10>)
   6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2074
}
   8:	4618      	mov	r0, r3
   a:	46bd      	mov	sp, r7
   c:	bc80      	pop	{r7}
   e:	4770      	bx	lr
  10:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_TamperTriggerConfig:

00000000 <RTC_TamperTriggerConfig>:
RTC_TamperTriggerConfig():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2106
  *     @arg RTC_TamperTrigger_LowLevel: Low Level of the tamper pin causes tamper event.
  *     @arg RTC_TamperTrigger_HighLevel: High Level of the tamper pin causes tamper event.
  * @retval None
  */
void RTC_TamperTriggerConfig(uint32_t RTC_Tamper, uint32_t RTC_TamperTrigger)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	6039      	str	r1, [r7, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2111
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER(RTC_Tamper)); 
  assert_param(IS_RTC_TAMPER_TRIGGER(RTC_TamperTrigger));
 
  if (RTC_TamperTrigger == RTC_TamperTrigger_RisingEdge)
   a:	683b      	ldr	r3, [r7, #0]
   c:	2b00      	cmp	r3, #0
   e:	d10b      	bne.n	28 <RTC_TamperTriggerConfig+0x28>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2114
  {  
    /* Configure the RTC_TAFCR register */
    RTC->TAFCR &= (uint32_t)((uint32_t)~(RTC_Tamper << 1));	
  10:	4b0c      	ldr	r3, [pc, #48]	; (44 <RTC_TamperTriggerConfig+0x44>)
  12:	4a0c      	ldr	r2, [pc, #48]	; (44 <RTC_TamperTriggerConfig+0x44>)
  14:	6c11      	ldr	r1, [r2, #64]	; 0x40
  16:	687a      	ldr	r2, [r7, #4]
  18:	ea4f 0242 	mov.w	r2, r2, lsl #1
  1c:	ea6f 0202 	mvn.w	r2, r2
  20:	ea01 0202 	and.w	r2, r1, r2
  24:	641a      	str	r2, [r3, #64]	; 0x40
  26:	e008      	b.n	3a <RTC_TamperTriggerConfig+0x3a>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2119
  }
  else
  { 
    /* Configure the RTC_TAFCR register */
    RTC->TAFCR |= (uint32_t)(RTC_Tamper << 1);  
  28:	4b06      	ldr	r3, [pc, #24]	; (44 <RTC_TamperTriggerConfig+0x44>)
  2a:	4a06      	ldr	r2, [pc, #24]	; (44 <RTC_TamperTriggerConfig+0x44>)
  2c:	6c11      	ldr	r1, [r2, #64]	; 0x40
  2e:	687a      	ldr	r2, [r7, #4]
  30:	ea4f 0242 	mov.w	r2, r2, lsl #1
  34:	ea41 0202 	orr.w	r2, r1, r2
  38:	641a      	str	r2, [r3, #64]	; 0x40
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2121
  }  
}
  3a:	f107 070c 	add.w	r7, r7, #12
  3e:	46bd      	mov	sp, r7
  40:	bc80      	pop	{r7}
  42:	4770      	bx	lr
  44:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_TamperCmd:

00000000 <RTC_TamperCmd>:
RTC_TamperCmd():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2132
  * @param  NewState: new state of the tamper pin.
  *          This parameter can be: ENABLE or DISABLE.                   
  * @retval None
  */
void RTC_TamperCmd(uint32_t RTC_Tamper, FunctionalState NewState)
{
   0:	b083b480 	.word	0xb083b480
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	70fb      	strb	r3, [r7, #3]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2137
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER(RTC_Tamper));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
   c:	78fb      	ldrb	r3, [r7, #3]
   e:	2b00      	cmp	r3, #0
  10:	d007      	beq.n	22 <RTC_TamperCmd+0x22>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2140
  {
    /* Enable the selected Tamper pin */
    RTC->TAFCR |= (uint32_t)RTC_Tamper;
  12:	4b0b      	ldr	r3, [pc, #44]	; (40 <RTC_TamperCmd+0x40>)
  14:	4a0a      	ldr	r2, [pc, #40]	; (40 <RTC_TamperCmd+0x40>)
  16:	6c11      	ldr	r1, [r2, #64]	; 0x40
  18:	687a      	ldr	r2, [r7, #4]
  1a:	ea41 0202 	orr.w	r2, r1, r2
  1e:	641a      	str	r2, [r3, #64]	; 0x40
  20:	e008      	b.n	34 <RTC_TamperCmd+0x34>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2145
  }
  else
  {
    /* Disable the selected Tamper pin */
    RTC->TAFCR &= (uint32_t)~RTC_Tamper;    
  22:	4b07      	ldr	r3, [pc, #28]	; (40 <RTC_TamperCmd+0x40>)
  24:	4a06      	ldr	r2, [pc, #24]	; (40 <RTC_TamperCmd+0x40>)
  26:	6c11      	ldr	r1, [r2, #64]	; 0x40
  28:	687a      	ldr	r2, [r7, #4]
  2a:	ea6f 0202 	mvn.w	r2, r2
  2e:	ea01 0202 	and.w	r2, r1, r2
  32:	641a      	str	r2, [r3, #64]	; 0x40
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2147
  }  
}
  34:	f107 070c 	add.w	r7, r7, #12
  38:	46bd      	mov	sp, r7
  3a:	bc80      	pop	{r7}
  3c:	4770      	bx	lr
  3e:	bf00      	nop
  40:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_TamperFilterConfig:

00000000 <RTC_TamperFilterConfig>:
RTC_TamperFilterConfig():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2163
  *     @arg RTC_TamperFilter_8Sample: Tamper is activated after 8 consecutive 
  *                                    samples at the active level 
  * @retval None
  */
void RTC_TamperFilterConfig(uint32_t RTC_TamperFilter)
{
   0:	b083b480 	.word	0xb083b480
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2168
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER_FILTER(RTC_TamperFilter));
   
  /* Clear TAMPFLT[1:0] bits in the RTC_TAFCR register */
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFLT);
   8:	4b08      	ldr	r3, [pc, #32]	; (2c <RTC_TamperFilterConfig+0x2c>)
   a:	4a08      	ldr	r2, [pc, #32]	; (2c <RTC_TamperFilterConfig+0x2c>)
   c:	6c12      	ldr	r2, [r2, #64]	; 0x40
   e:	f422 52c0 	bic.w	r2, r2, #6144	; 0x1800
  12:	641a      	str	r2, [r3, #64]	; 0x40
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2171

  /* Configure the RTC_TAFCR register */
  RTC->TAFCR |= (uint32_t)RTC_TamperFilter;
  14:	4b05      	ldr	r3, [pc, #20]	; (2c <RTC_TamperFilterConfig+0x2c>)
  16:	4a05      	ldr	r2, [pc, #20]	; (2c <RTC_TamperFilterConfig+0x2c>)
  18:	6c11      	ldr	r1, [r2, #64]	; 0x40
  1a:	687a      	ldr	r2, [r7, #4]
  1c:	ea41 0202 	orr.w	r2, r1, r2
  20:	641a      	str	r2, [r3, #64]	; 0x40
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2172
}
  22:	f107 070c 	add.w	r7, r7, #12
  26:	46bd      	mov	sp, r7
  28:	bc80      	pop	{r7}
  2a:	4770      	bx	lr
  2c:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_TamperSamplingFreqConfig:

00000000 <RTC_TamperSamplingFreqConfig>:
RTC_TamperSamplingFreqConfig():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2197
  *     @arg RTC_TamperSamplingFreq_RTCCLK_Div256: Each of the tamper inputs are sampled
  *                                           with a frequency =  RTCCLK / 256  
  * @retval None
  */
void RTC_TamperSamplingFreqConfig(uint32_t RTC_TamperSamplingFreq)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2202
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(RTC_TamperSamplingFreq));
 
  /* Clear TAMPFREQ[2:0] bits in the RTC_TAFCR register */
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFREQ);
   8:	4b08      	ldr	r3, [pc, #32]	; (2c <RTC_TamperSamplingFreqConfig+0x2c>)
   a:	4a08      	ldr	r2, [pc, #32]	; (2c <RTC_TamperSamplingFreqConfig+0x2c>)
   c:	6c12      	ldr	r2, [r2, #64]	; 0x40
   e:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
  12:	641a      	str	r2, [r3, #64]	; 0x40
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2205

  /* Configure the RTC_TAFCR register */
  RTC->TAFCR |= (uint32_t)RTC_TamperSamplingFreq;
  14:	4b05      	ldr	r3, [pc, #20]	; (2c <RTC_TamperSamplingFreqConfig+0x2c>)
  16:	4a05      	ldr	r2, [pc, #20]	; (2c <RTC_TamperSamplingFreqConfig+0x2c>)
  18:	6c11      	ldr	r1, [r2, #64]	; 0x40
  1a:	687a      	ldr	r2, [r7, #4]
  1c:	ea41 0202 	orr.w	r2, r1, r2
  20:	641a      	str	r2, [r3, #64]	; 0x40
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2206
}
  22:	f107 070c 	add.w	r7, r7, #12
  26:	46bd      	mov	sp, r7
  28:	bc80      	pop	{r7}
  2a:	4770      	bx	lr
  2c:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_TamperPinsPrechargeDuration:

00000000 <RTC_TamperPinsPrechargeDuration>:
RTC_TamperPinsPrechargeDuration():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2220
  *     @arg RTC_TamperPrechargeDuration_4RTCCLK: Tamper pins are precharged before sampling during 4 RTCCLK cycle    
  *     @arg RTC_TamperPrechargeDuration_8RTCCLK: Tamper pins are precharged before sampling during 8 RTCCLK cycle
  * @retval None
  */
void RTC_TamperPinsPrechargeDuration(uint32_t RTC_TamperPrechargeDuration)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2225
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(RTC_TamperPrechargeDuration));
   
  /* Clear TAMPPRCH[1:0] bits in the RTC_TAFCR register */
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPPRCH);
   8:	4b08      	ldr	r3, [pc, #32]	; (2c <RTC_TamperPinsPrechargeDuration+0x2c>)
   a:	4a08      	ldr	r2, [pc, #32]	; (2c <RTC_TamperPinsPrechargeDuration+0x2c>)
   c:	6c12      	ldr	r2, [r2, #64]	; 0x40
   e:	f422 42c0 	bic.w	r2, r2, #24576	; 0x6000
  12:	641a      	str	r2, [r3, #64]	; 0x40
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2228

  /* Configure the RTC_TAFCR register */
  RTC->TAFCR |= (uint32_t)RTC_TamperPrechargeDuration;
  14:	4b05      	ldr	r3, [pc, #20]	; (2c <RTC_TamperPinsPrechargeDuration+0x2c>)
  16:	4a05      	ldr	r2, [pc, #20]	; (2c <RTC_TamperPinsPrechargeDuration+0x2c>)
  18:	6c11      	ldr	r1, [r2, #64]	; 0x40
  1a:	687a      	ldr	r2, [r7, #4]
  1c:	ea41 0202 	orr.w	r2, r1, r2
  20:	641a      	str	r2, [r3, #64]	; 0x40
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2229
}
  22:	f107 070c 	add.w	r7, r7, #12
  26:	46bd      	mov	sp, r7
  28:	bc80      	pop	{r7}
  2a:	4770      	bx	lr
  2c:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_TimeStampOnTamperDetectionCmd:

00000000 <RTC_TimeStampOnTamperDetectionCmd>:
RTC_TimeStampOnTamperDetectionCmd():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2240
  * @param  NewState: new state of the timestamp on tamper event.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RTC_TimeStampOnTamperDetectionCmd(FunctionalState NewState)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	4603      	mov	r3, r0
   8:	71fb      	strb	r3, [r7, #7]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2244
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
   
  if (NewState != DISABLE)
   a:	79fb      	ldrb	r3, [r7, #7]
   c:	2b00      	cmp	r3, #0
   e:	d006      	beq.n	1e <RTC_TimeStampOnTamperDetectionCmd+0x1e>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2247
  {
    /* Save timestamp on tamper detection event */
    RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPTS;
  10:	4b08      	ldr	r3, [pc, #32]	; (34 <RTC_TimeStampOnTamperDetectionCmd+0x34>)
  12:	4a08      	ldr	r2, [pc, #32]	; (34 <RTC_TimeStampOnTamperDetectionCmd+0x34>)
  14:	6c12      	ldr	r2, [r2, #64]	; 0x40
  16:	f042 0280 	orr.w	r2, r2, #128	; 0x80
  1a:	641a      	str	r2, [r3, #64]	; 0x40
  1c:	e005      	b.n	2a <RTC_TimeStampOnTamperDetectionCmd+0x2a>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2252
  }
  else
  {
    /* Tamper detection does not cause a timestamp to be saved */
    RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPTS;    
  1e:	4b05      	ldr	r3, [pc, #20]	; (34 <RTC_TimeStampOnTamperDetectionCmd+0x34>)
  20:	4a04      	ldr	r2, [pc, #16]	; (34 <RTC_TimeStampOnTamperDetectionCmd+0x34>)
  22:	6c12      	ldr	r2, [r2, #64]	; 0x40
  24:	f022 0280 	bic.w	r2, r2, #128	; 0x80
  28:	641a      	str	r2, [r3, #64]	; 0x40
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2254
  }
}
  2a:	f107 070c 	add.w	r7, r7, #12
  2e:	46bd      	mov	sp, r7
  30:	bc80      	pop	{r7}
  32:	4770      	bx	lr
  34:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_TamperPullUpCmd:

00000000 <RTC_TamperPullUpCmd>:
RTC_TamperPullUpCmd():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2263
  * @param  NewState: new state of tamper pull up.
  *   This parameter can be: ENABLE or DISABLE.                   
  * @retval None
  */
void RTC_TamperPullUpCmd(FunctionalState NewState)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	4603      	mov	r3, r0
   8:	71fb      	strb	r3, [r7, #7]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2267
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
 if (NewState != DISABLE)
   a:	79fb      	ldrb	r3, [r7, #7]
   c:	2b00      	cmp	r3, #0
   e:	d006      	beq.n	1e <RTC_TamperPullUpCmd+0x1e>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2270
  {
    /* Enable precharge of the selected Tamper pin */
    RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPPUDIS; 
  10:	4b08      	ldr	r3, [pc, #32]	; (34 <RTC_TamperPullUpCmd+0x34>)
  12:	4a08      	ldr	r2, [pc, #32]	; (34 <RTC_TamperPullUpCmd+0x34>)
  14:	6c12      	ldr	r2, [r2, #64]	; 0x40
  16:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
  1a:	641a      	str	r2, [r3, #64]	; 0x40
  1c:	e005      	b.n	2a <RTC_TamperPullUpCmd+0x2a>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2275
  }
  else
  {
    /* Disable precharge of the selected Tamper pin */
    RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPPUDIS;    
  1e:	4b05      	ldr	r3, [pc, #20]	; (34 <RTC_TamperPullUpCmd+0x34>)
  20:	4a04      	ldr	r2, [pc, #16]	; (34 <RTC_TamperPullUpCmd+0x34>)
  22:	6c12      	ldr	r2, [r2, #64]	; 0x40
  24:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
  28:	641a      	str	r2, [r3, #64]	; 0x40
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2277
  } 
}
  2a:	f107 070c 	add.w	r7, r7, #12
  2e:	46bd      	mov	sp, r7
  30:	bc80      	pop	{r7}
  32:	4770      	bx	lr
  34:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_WriteBackupRegister:

00000000 <RTC_WriteBackupRegister>:
RTC_WriteBackupRegister():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2304
  *                          specify the register.
  * @param  Data: Data to be written in the specified RTC Backup data register.                     
  * @retval None
  */
void RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data)
{
   0:	b085b480 	.word	0xb085b480
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	6039      	str	r1, [r7, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2305
  __IO uint32_t tmp = 0;
   a:	f04f 0300 	mov.w	r3, #0
   e:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2310
  
  /* Check the parameters */
  assert_param(IS_RTC_BKP(RTC_BKP_DR));

  tmp = RTC_BASE + 0x50;
  10:	4b07      	ldr	r3, [pc, #28]	; (30 <RTC_WriteBackupRegister+0x30>)
  12:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2311
  tmp += (RTC_BKP_DR * 4);
  14:	687b      	ldr	r3, [r7, #4]
  16:	ea4f 0283 	mov.w	r2, r3, lsl #2
  1a:	68fb      	ldr	r3, [r7, #12]
  1c:	18d3      	adds	r3, r2, r3
  1e:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2314

  /* Write the specified register */
  *(__IO uint32_t *)tmp = (uint32_t)Data;
  20:	68fb      	ldr	r3, [r7, #12]
  22:	683a      	ldr	r2, [r7, #0]
  24:	601a      	str	r2, [r3, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2315
}
  26:	f107 0714 	add.w	r7, r7, #20
  2a:	46bd      	mov	sp, r7
  2c:	bc80      	pop	{r7}
  2e:	4770      	bx	lr
  30:	40002850 	.word	0x40002850

Disassembly of section .text.RTC_ReadBackupRegister:

00000000 <RTC_ReadBackupRegister>:
RTC_ReadBackupRegister():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2325
  *          This parameter can be: RTC_BKP_DRx where x can be from 0 to 19 to 
  *                          specify the register.                   
  * @retval None
  */
uint32_t RTC_ReadBackupRegister(uint32_t RTC_BKP_DR)
{
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2326
  __IO uint32_t tmp = 0;
   8:	f04f 0300 	mov.w	r3, #0
   c:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2331
  
  /* Check the parameters */
  assert_param(IS_RTC_BKP(RTC_BKP_DR));

  tmp = RTC_BASE + 0x50;
   e:	4b08      	ldr	r3, [pc, #32]	; (30 <RTC_ReadBackupRegister+0x30>)
  10:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2332
  tmp += (RTC_BKP_DR * 4);
  12:	687b      	ldr	r3, [r7, #4]
  14:	ea4f 0283 	mov.w	r2, r3, lsl #2
  18:	68fb      	ldr	r3, [r7, #12]
  1a:	18d3      	adds	r3, r2, r3
  1c:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2335
  
  /* Read the specified register */
  return (*(__IO uint32_t *)tmp);
  1e:	68fb      	ldr	r3, [r7, #12]
  20:	681b      	ldr	r3, [r3, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2336
}
  22:	4618      	mov	r0, r3
  24:	f107 0714 	add.w	r7, r7, #20
  28:	46bd      	mov	sp, r7
  2a:	bc80      	pop	{r7}
  2c:	4770      	bx	lr
  2e:	bf00      	nop
  30:	40002850 	.word	0x40002850

Disassembly of section .text.RTC_TamperPinSelection:

00000000 <RTC_TamperPinSelection>:
RTC_TamperPinSelection():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2364
  *            @arg RTC_TamperPin_PC13: PC13 is selected as RTC Tamper Pin.
  *            @arg RTC_TamperPin_PI8: PI8 is selected as RTC Tamper Pin.    
  * @retval None
  */
void RTC_TamperPinSelection(uint32_t RTC_TamperPin)
{
   0:	b083b480 	.word	0xb083b480
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2368
  /* Check the parameters */
  assert_param(IS_RTC_TAMPER_PIN(RTC_TamperPin));
  
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPINSEL);
   8:	4b08      	ldr	r3, [pc, #32]	; (2c <RTC_TamperPinSelection+0x2c>)
   a:	4a08      	ldr	r2, [pc, #32]	; (2c <RTC_TamperPinSelection+0x2c>)
   c:	6c12      	ldr	r2, [r2, #64]	; 0x40
   e:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
  12:	641a      	str	r2, [r3, #64]	; 0x40
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2369
  RTC->TAFCR |= (uint32_t)(RTC_TamperPin);  
  14:	4b05      	ldr	r3, [pc, #20]	; (2c <RTC_TamperPinSelection+0x2c>)
  16:	4a05      	ldr	r2, [pc, #20]	; (2c <RTC_TamperPinSelection+0x2c>)
  18:	6c11      	ldr	r1, [r2, #64]	; 0x40
  1a:	687a      	ldr	r2, [r7, #4]
  1c:	ea41 0202 	orr.w	r2, r1, r2
  20:	641a      	str	r2, [r3, #64]	; 0x40
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2370
}
  22:	f107 070c 	add.w	r7, r7, #12
  26:	46bd      	mov	sp, r7
  28:	bc80      	pop	{r7}
  2a:	4770      	bx	lr
  2c:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_TimeStampPinSelection:

00000000 <RTC_TimeStampPinSelection>:
RTC_TimeStampPinSelection():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2381
  *            @arg RTC_TimeStampPin_PC13: PC13 is selected as RTC TimeStamp Pin.
  *            @arg RTC_TimeStampPin_PI8: PI8 is selected as RTC TimeStamp Pin.    
  * @retval None
  */
void RTC_TimeStampPinSelection(uint32_t RTC_TimeStampPin)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2385
  /* Check the parameters */
  assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));
  
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TSINSEL);
   8:	4b08      	ldr	r3, [pc, #32]	; (2c <RTC_TimeStampPinSelection+0x2c>)
   a:	4a08      	ldr	r2, [pc, #32]	; (2c <RTC_TimeStampPinSelection+0x2c>)
   c:	6c12      	ldr	r2, [r2, #64]	; 0x40
   e:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
  12:	641a      	str	r2, [r3, #64]	; 0x40
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2386
  RTC->TAFCR |= (uint32_t)(RTC_TimeStampPin);  
  14:	4b05      	ldr	r3, [pc, #20]	; (2c <RTC_TimeStampPinSelection+0x2c>)
  16:	4a05      	ldr	r2, [pc, #20]	; (2c <RTC_TimeStampPinSelection+0x2c>)
  18:	6c11      	ldr	r1, [r2, #64]	; 0x40
  1a:	687a      	ldr	r2, [r7, #4]
  1c:	ea41 0202 	orr.w	r2, r1, r2
  20:	641a      	str	r2, [r3, #64]	; 0x40
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2387
}
  22:	f107 070c 	add.w	r7, r7, #12
  26:	46bd      	mov	sp, r7
  28:	bc80      	pop	{r7}
  2a:	4770      	bx	lr
  2c:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_OutputTypeConfig:

00000000 <RTC_OutputTypeConfig>:
RTC_OutputTypeConfig():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2400
  *            @arg RTC_OutputType_PushPull:  RTC Output (PC13) is configured in 
  *                                    Push Pull mode.    
  * @retval None
  */
void RTC_OutputTypeConfig(uint32_t RTC_OutputType)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2404
  /* Check the parameters */
  assert_param(IS_RTC_OUTPUT_TYPE(RTC_OutputType));
  
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_ALARMOUTTYPE);
   8:	4b08      	ldr	r3, [pc, #32]	; (2c <RTC_OutputTypeConfig+0x2c>)
   a:	4a08      	ldr	r2, [pc, #32]	; (2c <RTC_OutputTypeConfig+0x2c>)
   c:	6c12      	ldr	r2, [r2, #64]	; 0x40
   e:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
  12:	641a      	str	r2, [r3, #64]	; 0x40
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2405
  RTC->TAFCR |= (uint32_t)(RTC_OutputType);  
  14:	4b05      	ldr	r3, [pc, #20]	; (2c <RTC_OutputTypeConfig+0x2c>)
  16:	4a05      	ldr	r2, [pc, #20]	; (2c <RTC_OutputTypeConfig+0x2c>)
  18:	6c11      	ldr	r1, [r2, #64]	; 0x40
  1a:	687a      	ldr	r2, [r7, #4]
  1c:	ea41 0202 	orr.w	r2, r1, r2
  20:	641a      	str	r2, [r3, #64]	; 0x40
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2406
}
  22:	f107 070c 	add.w	r7, r7, #12
  26:	46bd      	mov	sp, r7
  28:	bc80      	pop	{r7}
  2a:	4770      	bx	lr
  2c:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_SynchroShiftConfig:

00000000 <RTC_SynchroShiftConfig>:
RTC_SynchroShiftConfig():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2438
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: RTC Shift registers are configured
  *          - ERROR: RTC Shift registers are not configured
*/
ErrorStatus RTC_SynchroShiftConfig(uint32_t RTC_ShiftAdd1S, uint32_t RTC_ShiftSubFS)
{
   0:	b580      	push	{r7, lr}
   2:	b084      	sub	sp, #16
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	6039      	str	r1, [r7, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2439
  ErrorStatus status = ERROR;
   a:	f04f 0300 	mov.w	r3, #0
   e:	73fb      	strb	r3, [r7, #15]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2440
  uint32_t shpfcount = 0;
  10:	f04f 0300 	mov.w	r3, #0
  14:	60bb      	str	r3, [r7, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2447
  /* Check the parameters */
  assert_param(IS_RTC_SHIFT_ADD1S(RTC_ShiftAdd1S));
  assert_param(IS_RTC_SHIFT_SUBFS(RTC_ShiftSubFS));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
  16:	4b26      	ldr	r3, [pc, #152]	; (b0 <RTC_SynchroShiftConfig+0xb0>)
  18:	f04f 02ca 	mov.w	r2, #202	; 0xca
  1c:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2448
  RTC->WPR = 0x53;
  1e:	4b24      	ldr	r3, [pc, #144]	; (b0 <RTC_SynchroShiftConfig+0xb0>)
  20:	f04f 0253 	mov.w	r2, #83	; 0x53
  24:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2451
  
  /* Check if a Shift is pending*/
  if ((RTC->ISR & RTC_ISR_SHPF) != RESET)
  26:	4b22      	ldr	r3, [pc, #136]	; (b0 <RTC_SynchroShiftConfig+0xb0>)
  28:	68db      	ldr	r3, [r3, #12]
  2a:	f003 0308 	and.w	r3, r3, #8
  2e:	2b00      	cmp	r3, #0
  30:	d00e      	beq.n	50 <RTC_SynchroShiftConfig+0x50>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2454
  {
    /* Wait until the shift is completed*/
    while (((RTC->ISR & RTC_ISR_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
  32:	e003      	b.n	3c <RTC_SynchroShiftConfig+0x3c>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2456
    {
      shpfcount++;
  34:	68bb      	ldr	r3, [r7, #8]
  36:	f103 0301 	add.w	r3, r3, #1
  3a:	60bb      	str	r3, [r7, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2454
  
  /* Check if a Shift is pending*/
  if ((RTC->ISR & RTC_ISR_SHPF) != RESET)
  {
    /* Wait until the shift is completed*/
    while (((RTC->ISR & RTC_ISR_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
  3c:	4b1c      	ldr	r3, [pc, #112]	; (b0 <RTC_SynchroShiftConfig+0xb0>)
  3e:	68db      	ldr	r3, [r3, #12]
  40:	f003 0308 	and.w	r3, r3, #8
  44:	2b00      	cmp	r3, #0
  46:	d003      	beq.n	50 <RTC_SynchroShiftConfig+0x50>
  48:	68bb      	ldr	r3, [r7, #8]
  4a:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
  4e:	d1f1      	bne.n	34 <RTC_SynchroShiftConfig+0x34>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2461
      shpfcount++;
    }
  }

  /* Check if the Shift pending is completed or if there is no Shift operation at all*/
  if ((RTC->ISR & RTC_ISR_SHPF) == RESET)
  50:	4b17      	ldr	r3, [pc, #92]	; (b0 <RTC_SynchroShiftConfig+0xb0>)
  52:	68db      	ldr	r3, [r3, #12]
  54:	f003 0308 	and.w	r3, r3, #8
  58:	2b00      	cmp	r3, #0
  5a:	d11c      	bne.n	96 <RTC_SynchroShiftConfig+0x96>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2464
  {
    /* check if the reference clock detection is disabled */
    if((RTC->CR & RTC_CR_REFCKON) == RESET)
  5c:	4b14      	ldr	r3, [pc, #80]	; (b0 <RTC_SynchroShiftConfig+0xb0>)
  5e:	689b      	ldr	r3, [r3, #8]
  60:	f003 0310 	and.w	r3, r3, #16
  64:	2b00      	cmp	r3, #0
  66:	d112      	bne.n	8e <RTC_SynchroShiftConfig+0x8e>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2467
    {
      /* Configure the Shift settings */
      RTC->SHIFTR = (uint32_t)(uint32_t)(RTC_ShiftSubFS) | (uint32_t)(RTC_ShiftAdd1S);
  68:	4b11      	ldr	r3, [pc, #68]	; (b0 <RTC_SynchroShiftConfig+0xb0>)
  6a:	6839      	ldr	r1, [r7, #0]
  6c:	687a      	ldr	r2, [r7, #4]
  6e:	ea41 0202 	orr.w	r2, r1, r2
  72:	62da      	str	r2, [r3, #44]	; 0x2c
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2469
    
      if(RTC_WaitForSynchro() == ERROR)
  74:	f7ff fffe 	bl	0 <RTC_SynchroShiftConfig>
  78:	4603      	mov	r3, r0
  7a:	2b00      	cmp	r3, #0
  7c:	d103      	bne.n	86 <RTC_SynchroShiftConfig+0x86>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2471
      {
        status = ERROR;
  7e:	f04f 0300 	mov.w	r3, #0
  82:	73fb      	strb	r3, [r7, #15]
  84:	e00a      	b.n	9c <RTC_SynchroShiftConfig+0x9c>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2475
      }
      else
      {
        status = SUCCESS;
  86:	f04f 0301 	mov.w	r3, #1
  8a:	73fb      	strb	r3, [r7, #15]
  8c:	e006      	b.n	9c <RTC_SynchroShiftConfig+0x9c>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2480
      }
    }
    else
    {
      status = ERROR;
  8e:	f04f 0300 	mov.w	r3, #0
  92:	73fb      	strb	r3, [r7, #15]
  94:	e002      	b.n	9c <RTC_SynchroShiftConfig+0x9c>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2485
    }
  }
  else
  {
    status = ERROR;
  96:	f04f 0300 	mov.w	r3, #0
  9a:	73fb      	strb	r3, [r7, #15]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2489
  }

  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF;
  9c:	4b04      	ldr	r3, [pc, #16]	; (b0 <RTC_SynchroShiftConfig+0xb0>)
  9e:	f04f 02ff 	mov.w	r2, #255	; 0xff
  a2:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2491
  
  return (ErrorStatus)(status);
  a4:	7bfb      	ldrb	r3, [r7, #15]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2492
}
  a6:	4618      	mov	r0, r3
  a8:	f107 0710 	add.w	r7, r7, #16
  ac:	46bd      	mov	sp, r7
  ae:	bd80      	pop	{r7, pc}
  b0:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_ITConfig:

00000000 <RTC_ITConfig>:
RTC_ITConfig():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2558
  * @param  NewState: new state of the specified RTC interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState)
{
   0:	b083b480 	.word	0xb083b480
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	70fb      	strb	r3, [r7, #3]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2564
  /* Check the parameters */
  assert_param(IS_RTC_CONFIG_IT(RTC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Disable the write protection for RTC registers */
  RTC->WPR = 0xCA;
   c:	4b1e      	ldr	r3, [pc, #120]	; (88 <RTC_ITConfig+0x88>)
   e:	f04f 02ca 	mov.w	r2, #202	; 0xca
  12:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2565
  RTC->WPR = 0x53;
  14:	4b1c      	ldr	r3, [pc, #112]	; (88 <RTC_ITConfig+0x88>)
  16:	f04f 0253 	mov.w	r2, #83	; 0x53
  1a:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2567

  if (NewState != DISABLE)
  1c:	78fb      	ldrb	r3, [r7, #3]
  1e:	2b00      	cmp	r3, #0
  20:	d012      	beq.n	48 <RTC_ITConfig+0x48>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2570
  {
    /* Configure the Interrupts in the RTC_CR register */
    RTC->CR |= (uint32_t)(RTC_IT & ~RTC_TAFCR_TAMPIE);
  22:	4b19      	ldr	r3, [pc, #100]	; (88 <RTC_ITConfig+0x88>)
  24:	4a18      	ldr	r2, [pc, #96]	; (88 <RTC_ITConfig+0x88>)
  26:	6891      	ldr	r1, [r2, #8]
  28:	687a      	ldr	r2, [r7, #4]
  2a:	f022 0204 	bic.w	r2, r2, #4
  2e:	ea41 0202 	orr.w	r2, r1, r2
  32:	609a      	str	r2, [r3, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2572
    /* Configure the Tamper Interrupt in the RTC_TAFCR */
    RTC->TAFCR |= (uint32_t)(RTC_IT & RTC_TAFCR_TAMPIE);
  34:	4b14      	ldr	r3, [pc, #80]	; (88 <RTC_ITConfig+0x88>)
  36:	4a14      	ldr	r2, [pc, #80]	; (88 <RTC_ITConfig+0x88>)
  38:	6c11      	ldr	r1, [r2, #64]	; 0x40
  3a:	687a      	ldr	r2, [r7, #4]
  3c:	f002 0204 	and.w	r2, r2, #4
  40:	ea41 0202 	orr.w	r2, r1, r2
  44:	641a      	str	r2, [r3, #64]	; 0x40
  46:	e015      	b.n	74 <RTC_ITConfig+0x74>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2577
  }
  else
  {
    /* Configure the Interrupts in the RTC_CR register */
    RTC->CR &= (uint32_t)~(RTC_IT & (uint32_t)~RTC_TAFCR_TAMPIE);
  48:	4b0f      	ldr	r3, [pc, #60]	; (88 <RTC_ITConfig+0x88>)
  4a:	4a0f      	ldr	r2, [pc, #60]	; (88 <RTC_ITConfig+0x88>)
  4c:	6891      	ldr	r1, [r2, #8]
  4e:	687a      	ldr	r2, [r7, #4]
  50:	f022 0204 	bic.w	r2, r2, #4
  54:	ea6f 0202 	mvn.w	r2, r2
  58:	ea01 0202 	and.w	r2, r1, r2
  5c:	609a      	str	r2, [r3, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2579
    /* Configure the Tamper Interrupt in the RTC_TAFCR */
    RTC->TAFCR &= (uint32_t)~(RTC_IT & RTC_TAFCR_TAMPIE);
  5e:	4b0a      	ldr	r3, [pc, #40]	; (88 <RTC_ITConfig+0x88>)
  60:	4a09      	ldr	r2, [pc, #36]	; (88 <RTC_ITConfig+0x88>)
  62:	6c11      	ldr	r1, [r2, #64]	; 0x40
  64:	687a      	ldr	r2, [r7, #4]
  66:	f002 0204 	and.w	r2, r2, #4
  6a:	ea6f 0202 	mvn.w	r2, r2
  6e:	ea01 0202 	and.w	r2, r1, r2
  72:	641a      	str	r2, [r3, #64]	; 0x40
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2582
  }
  /* Enable the write protection for RTC registers */
  RTC->WPR = 0xFF; 
  74:	4b04      	ldr	r3, [pc, #16]	; (88 <RTC_ITConfig+0x88>)
  76:	f04f 02ff 	mov.w	r2, #255	; 0xff
  7a:	625a      	str	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2583
}
  7c:	f107 070c 	add.w	r7, r7, #12
  80:	46bd      	mov	sp, r7
  82:	bc80      	pop	{r7}
  84:	4770      	bx	lr
  86:	bf00      	nop
  88:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_GetFlagStatus:

00000000 <RTC_GetFlagStatus>:
RTC_GetFlagStatus():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2606
  *            @arg RTC_FLAG_ALRBWF: Alarm B Write flag
  *            @arg RTC_FLAG_ALRAWF: Alarm A write flag
  * @retval The new state of RTC_FLAG (SET or RESET).
  */
FlagStatus RTC_GetFlagStatus(uint32_t RTC_FLAG)
{
   0:	b085b480 	.word	0xb085b480
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2607
  FlagStatus bitstatus = RESET;
   8:	f04f 0300 	mov.w	r3, #0
   c:	73fb      	strb	r3, [r7, #15]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2608
  uint32_t tmpreg = 0;
   e:	f04f 0300 	mov.w	r3, #0
  12:	60bb      	str	r3, [r7, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2614
  
  /* Check the parameters */
  assert_param(IS_RTC_GET_FLAG(RTC_FLAG));
  
  /* Get all the flags */
  tmpreg = (uint32_t)(RTC->ISR & RTC_FLAGS_MASK);
  14:	4b0c      	ldr	r3, [pc, #48]	; (48 <RTC_GetFlagStatus+0x48>)
  16:	68da      	ldr	r2, [r3, #12]
  18:	4b0c      	ldr	r3, [pc, #48]	; (4c <RTC_GetFlagStatus+0x4c>)
  1a:	ea02 0303 	and.w	r3, r2, r3
  1e:	60bb      	str	r3, [r7, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2617
  
  /* Return the status of the flag */
  if ((tmpreg & RTC_FLAG) != (uint32_t)RESET)
  20:	68ba      	ldr	r2, [r7, #8]
  22:	687b      	ldr	r3, [r7, #4]
  24:	ea02 0303 	and.w	r3, r2, r3
  28:	2b00      	cmp	r3, #0
  2a:	d003      	beq.n	34 <RTC_GetFlagStatus+0x34>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2619
  {
    bitstatus = SET;
  2c:	f04f 0301 	mov.w	r3, #1
  30:	73fb      	strb	r3, [r7, #15]
  32:	e002      	b.n	3a <RTC_GetFlagStatus+0x3a>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2623
  }
  else
  {
    bitstatus = RESET;
  34:	f04f 0300 	mov.w	r3, #0
  38:	73fb      	strb	r3, [r7, #15]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2625
  }
  return bitstatus;
  3a:	7bfb      	ldrb	r3, [r7, #15]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2626
}
  3c:	4618      	mov	r0, r3
  3e:	f107 0714 	add.w	r7, r7, #20
  42:	46bd      	mov	sp, r7
  44:	bc80      	pop	{r7}
  46:	4770      	bx	lr
  48:	40002800 	.word	0x40002800
  4c:	00013f7f 	.word	0x00013f7f

Disassembly of section .text.RTC_ClearFlag:

00000000 <RTC_ClearFlag>:
RTC_ClearFlag():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2642
  *            @arg RTC_FLAG_ALRAF: Alarm A flag
  *            @arg RTC_FLAG_RSF: Registers Synchronized flag
  * @retval None
  */
void RTC_ClearFlag(uint32_t RTC_FLAG)
{
   0:	b083b480 	.word	0xb083b480
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2647
  /* Check the parameters */
  assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG));

  /* Clear the Flags in the RTC_ISR register */
  RTC->ISR = (uint32_t)((uint32_t)(~((RTC_FLAG | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT)));  
   8:	4a0a      	ldr	r2, [pc, #40]	; (34 <RTC_ClearFlag+0x34>)
   a:	687b      	ldr	r3, [r7, #4]
   c:	ea4f 4303 	mov.w	r3, r3, lsl #16
  10:	ea4f 4313 	mov.w	r3, r3, lsr #16
  14:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  18:	ea6f 0103 	mvn.w	r1, r3
  1c:	4b05      	ldr	r3, [pc, #20]	; (34 <RTC_ClearFlag+0x34>)
  1e:	68db      	ldr	r3, [r3, #12]
  20:	f003 0380 	and.w	r3, r3, #128	; 0x80
  24:	ea41 0303 	orr.w	r3, r1, r3
  28:	60d3      	str	r3, [r2, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2648
}
  2a:	f107 070c 	add.w	r7, r7, #12
  2e:	46bd      	mov	sp, r7
  30:	bc80      	pop	{r7}
  32:	4770      	bx	lr
  34:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_GetITStatus:

00000000 <RTC_GetITStatus>:
RTC_GetITStatus():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2662
  *            @arg RTC_IT_ALRA: Alarm A interrupt 
  *            @arg RTC_IT_TAMP1: Tamper 1 event interrupt 
  * @retval The new state of RTC_IT (SET or RESET).
  */
ITStatus RTC_GetITStatus(uint32_t RTC_IT)
{
   0:	b480      	push	{r7}
   2:	b087      	sub	sp, #28
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2663
  ITStatus bitstatus = RESET;
   8:	f04f 0300 	mov.w	r3, #0
   c:	75fb      	strb	r3, [r7, #23]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2664
  uint32_t tmpreg = 0, enablestatus = 0;
   e:	f04f 0300 	mov.w	r3, #0
  12:	613b      	str	r3, [r7, #16]
  14:	f04f 0300 	mov.w	r3, #0
  18:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2670
 
  /* Check the parameters */
  assert_param(IS_RTC_GET_IT(RTC_IT));
  
  /* Get the TAMPER Interrupt enable bit and pending bit */
  tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
  1a:	4b19      	ldr	r3, [pc, #100]	; (80 <RTC_GetITStatus+0x80>)
  1c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  1e:	f003 0304 	and.w	r3, r3, #4
  22:	613b      	str	r3, [r7, #16]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2673
 
  /* Get the Interrupt enable Status */
  enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & (RTC_IT >> 15)));
  24:	4b16      	ldr	r3, [pc, #88]	; (80 <RTC_GetITStatus+0x80>)
  26:	689a      	ldr	r2, [r3, #8]
  28:	687b      	ldr	r3, [r7, #4]
  2a:	401a      	ands	r2, r3
  2c:	687b      	ldr	r3, [r7, #4]
  2e:	ea4f 31d3 	mov.w	r1, r3, lsr #15
  32:	693b      	ldr	r3, [r7, #16]
  34:	ea01 0303 	and.w	r3, r1, r3
  38:	ea42 0303 	orr.w	r3, r2, r3
  3c:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2676
  
  /* Get the Interrupt pending bit */
  tmpreg = (uint32_t)((RTC->ISR & (uint32_t)(RTC_IT >> 4)));
  3e:	4b10      	ldr	r3, [pc, #64]	; (80 <RTC_GetITStatus+0x80>)
  40:	68da      	ldr	r2, [r3, #12]
  42:	687b      	ldr	r3, [r7, #4]
  44:	ea4f 1313 	mov.w	r3, r3, lsr #4
  48:	ea02 0303 	and.w	r3, r2, r3
  4c:	613b      	str	r3, [r7, #16]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2679
  
  /* Get the status of the Interrupt */
  if ((enablestatus != (uint32_t)RESET) && ((tmpreg & 0x0000FFFF) != (uint32_t)RESET))
  4e:	68fb      	ldr	r3, [r7, #12]
  50:	2b00      	cmp	r3, #0
  52:	d00a      	beq.n	6a <RTC_GetITStatus+0x6a>
  54:	693b      	ldr	r3, [r7, #16]
  56:	ea4f 4303 	mov.w	r3, r3, lsl #16
  5a:	ea4f 4313 	mov.w	r3, r3, lsr #16
  5e:	2b00      	cmp	r3, #0
  60:	d003      	beq.n	6a <RTC_GetITStatus+0x6a>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2681
  {
    bitstatus = SET;
  62:	f04f 0301 	mov.w	r3, #1
  66:	75fb      	strb	r3, [r7, #23]
  68:	e002      	b.n	70 <RTC_GetITStatus+0x70>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2685
  }
  else
  {
    bitstatus = RESET;
  6a:	f04f 0300 	mov.w	r3, #0
  6e:	75fb      	strb	r3, [r7, #23]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2687
  }
  return bitstatus;
  70:	7dfb      	ldrb	r3, [r7, #23]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2688
}
  72:	4618      	mov	r0, r3
  74:	f107 071c 	add.w	r7, r7, #28
  78:	46bd      	mov	sp, r7
  7a:	bc80      	pop	{r7}
  7c:	4770      	bx	lr
  7e:	bf00      	nop
  80:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_ClearITPendingBit:

00000000 <RTC_ClearITPendingBit>:
RTC_ClearITPendingBit():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2702
  *            @arg RTC_IT_ALRA: Alarm A interrupt 
  *            @arg RTC_IT_TAMP1: Tamper 1 event interrupt 
  * @retval None
  */
void RTC_ClearITPendingBit(uint32_t RTC_IT)
{
   0:	b085b480 	.word	0xb085b480
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2703
  uint32_t tmpreg = 0;
   8:	f04f 0300 	mov.w	r3, #0
   c:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2709

  /* Check the parameters */
  assert_param(IS_RTC_CLEAR_IT(RTC_IT));

  /* Get the RTC_ISR Interrupt pending bits mask */
  tmpreg = (uint32_t)(RTC_IT >> 4);
   e:	687b      	ldr	r3, [r7, #4]
  10:	ea4f 1313 	mov.w	r3, r3, lsr #4
  14:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2712

  /* Clear the interrupt pending bits in the RTC_ISR register */
  RTC->ISR = (uint32_t)((uint32_t)(~((tmpreg | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT))); 
  16:	4a0b      	ldr	r2, [pc, #44]	; (44 <RTC_ClearITPendingBit+0x44>)
  18:	68fb      	ldr	r3, [r7, #12]
  1a:	ea4f 4303 	mov.w	r3, r3, lsl #16
  1e:	ea4f 4313 	mov.w	r3, r3, lsr #16
  22:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  26:	ea6f 0103 	mvn.w	r1, r3
  2a:	4b06      	ldr	r3, [pc, #24]	; (44 <RTC_ClearITPendingBit+0x44>)
  2c:	68db      	ldr	r3, [r3, #12]
  2e:	f003 0380 	and.w	r3, r3, #128	; 0x80
  32:	ea41 0303 	orr.w	r3, r1, r3
  36:	60d3      	str	r3, [r2, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2713
}
  38:	f107 0714 	add.w	r7, r7, #20
  3c:	46bd      	mov	sp, r7
  3e:	bc80      	pop	{r7}
  40:	4770      	bx	lr
  42:	bf00      	nop
  44:	40002800 	.word	0x40002800

Disassembly of section .text.RTC_ByteToBcd2:

00000000 <RTC_ByteToBcd2>:
RTC_ByteToBcd2():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2725
  * @brief  Converts a 2 digit decimal to BCD format.
  * @param  Value: Byte to be converted.
  * @retval Converted byte
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	4603      	mov	r3, r0
   8:	71fb      	strb	r3, [r7, #7]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2726
  uint8_t bcdhigh = 0;
   a:	f04f 0300 	mov.w	r3, #0
   e:	73fb      	strb	r3, [r7, #15]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2728
  
  while (Value >= 10)
  10:	e007      	b.n	22 <RTC_ByteToBcd2+0x22>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2730
  {
    bcdhigh++;
  12:	7bfb      	ldrb	r3, [r7, #15]
  14:	f103 0301 	add.w	r3, r3, #1
  18:	73fb      	strb	r3, [r7, #15]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2731
    Value -= 10;
  1a:	79fb      	ldrb	r3, [r7, #7]
  1c:	f1a3 030a 	sub.w	r3, r3, #10
  20:	71fb      	strb	r3, [r7, #7]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2728
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint8_t bcdhigh = 0;
  
  while (Value >= 10)
  22:	79fb      	ldrb	r3, [r7, #7]
  24:	2b09      	cmp	r3, #9
  26:	d8f4      	bhi.n	12 <RTC_ByteToBcd2+0x12>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2734
  {
    bcdhigh++;
    Value -= 10;
  }
  
  return  ((uint8_t)(bcdhigh << 4) | Value);
  28:	7bfb      	ldrb	r3, [r7, #15]
  2a:	ea4f 1303 	mov.w	r3, r3, lsl #4
  2e:	b2da      	uxtb	r2, r3
  30:	79fb      	ldrb	r3, [r7, #7]
  32:	ea42 0303 	orr.w	r3, r2, r3
  36:	b2db      	uxtb	r3, r3
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2735
}
  38:	4618      	mov	r0, r3
  3a:	f107 0714 	add.w	r7, r7, #20
  3e:	46bd      	mov	sp, r7
  40:	bc80      	pop	{r7}
  42:	4770      	bx	lr

Disassembly of section .text.RTC_Bcd2ToByte:

00000000 <RTC_Bcd2ToByte>:
RTC_Bcd2ToByte():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2743
  * @brief  Convert from 2 digit BCD to Binary.
  * @param  Value: BCD value to be converted.
  * @retval Converted word
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	4603      	mov	r3, r0
   8:	71fb      	strb	r3, [r7, #7]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2744
  uint8_t tmp = 0;
   a:	f04f 0300 	mov.w	r3, #0
   e:	73fb      	strb	r3, [r7, #15]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2745
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
  10:	79fb      	ldrb	r3, [r7, #7]
  12:	ea4f 1313 	mov.w	r3, r3, lsr #4
  16:	b2db      	uxtb	r3, r3
  18:	461a      	mov	r2, r3
  1a:	ea4f 0282 	mov.w	r2, r2, lsl #2
  1e:	18d3      	adds	r3, r2, r3
  20:	ea4f 0343 	mov.w	r3, r3, lsl #1
  24:	73fb      	strb	r3, [r7, #15]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2746
  return (tmp + (Value & (uint8_t)0x0F));
  26:	79fb      	ldrb	r3, [r7, #7]
  28:	f003 030f 	and.w	r3, r3, #15
  2c:	b2da      	uxtb	r2, r3
  2e:	7bfb      	ldrb	r3, [r7, #15]
  30:	18d3      	adds	r3, r2, r3
  32:	b2db      	uxtb	r3, r3
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_rtc.c:2747
}
  34:	4618      	mov	r0, r3
  36:	f107 0714 	add.w	r7, r7, #20
  3a:	46bd      	mov	sp, r7
  3c:	bc80      	pop	{r7}
  3e:	4770      	bx	lr
