
C:\Users\gcristian\Desktop\F429\Drivers\obj\stm32f4xx_i2c.o:     file format elf32-littlearm
C:\Users\gcristian\Desktop\F429\Drivers\obj\stm32f4xx_i2c.o


Disassembly of section .text.I2C_DeInit:

00000000 <I2C_DeInit>:
I2C_DeInit():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:138
  * @brief  Deinitialize the I2Cx peripheral registers to their default reset values.
  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
  * @retval None
  */
void I2C_DeInit(I2C_TypeDef* I2Cx)
{
   0:	b580      	push	{r7, lr}
   2:	b082      	sub	sp, #8
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:142
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  if (I2Cx == I2C1)
   8:	687a      	ldr	r2, [r7, #4]
   a:	4b1a      	ldr	r3, [pc, #104]	; (74 <I2C_DeInit+0x74>)
   c:	429a      	cmp	r2, r3
   e:	d10c      	bne.n	2a <I2C_DeInit+0x2a>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:145
  {
    /* Enable I2C1 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
  10:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
  14:	f04f 0101 	mov.w	r1, #1
  18:	f7ff fffe 	bl	0 <RCC_APB1PeriphResetCmd>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:147
    /* Release I2C1 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);    
  1c:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
  20:	f04f 0100 	mov.w	r1, #0
  24:	f7ff fffe 	bl	0 <RCC_APB1PeriphResetCmd>
  28:	e020      	b.n	6c <I2C_DeInit+0x6c>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:149
  }
  else if (I2Cx == I2C2)
  2a:	687a      	ldr	r2, [r7, #4]
  2c:	4b12      	ldr	r3, [pc, #72]	; (78 <I2C_DeInit+0x78>)
  2e:	429a      	cmp	r2, r3
  30:	d10c      	bne.n	4c <I2C_DeInit+0x4c>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:152
  {
    /* Enable I2C2 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
  32:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
  36:	f04f 0101 	mov.w	r1, #1
  3a:	f7ff fffe 	bl	0 <RCC_APB1PeriphResetCmd>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:154
    /* Release I2C2 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);      
  3e:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
  42:	f04f 0100 	mov.w	r1, #0
  46:	f7ff fffe 	bl	0 <RCC_APB1PeriphResetCmd>
  4a:	e00f      	b.n	6c <I2C_DeInit+0x6c>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:158
  }
  else 
  {
    if (I2Cx == I2C3)
  4c:	687a      	ldr	r2, [r7, #4]
  4e:	4b0b      	ldr	r3, [pc, #44]	; (7c <I2C_DeInit+0x7c>)
  50:	429a      	cmp	r2, r3
  52:	d10b      	bne.n	6c <I2C_DeInit+0x6c>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:161
    {
      /* Enable I2C3 reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, ENABLE);
  54:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
  58:	f04f 0101 	mov.w	r1, #1
  5c:	f7ff fffe 	bl	0 <RCC_APB1PeriphResetCmd>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:163
      /* Release I2C3 from reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, DISABLE);     
  60:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
  64:	f04f 0100 	mov.w	r1, #0
  68:	f7ff fffe 	bl	0 <RCC_APB1PeriphResetCmd>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:166
    }
  }
}
  6c:	f107 0708 	add.w	r7, r7, #8
  70:	46bd      	mov	sp, r7
  72:	bd80      	pop	{r7, pc}
  74:	40005400 	.word	0x40005400
  78:	40005800 	.word	0x40005800
  7c:	40005c00 	.word	0x40005c00

Disassembly of section .text.I2C_Init:

00000000 <I2C_Init>:
I2C_Init():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:181
  * @param  I2C_InitStruct: pointer to a I2C_InitTypeDef structure that contains 
  *         the configuration information for the specified I2C peripheral.
  * @retval None
  */
void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
{
   0:	b580      	push	{r7, lr}
   2:	b08a      	sub	sp, #40	; 0x28
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	6039      	str	r1, [r7, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:182
  uint16_t tmpreg = 0, freqrange = 0;
   a:	f04f 0300 	mov.w	r3, #0
   e:	84fb      	strh	r3, [r7, #38]	; 0x26
  10:	f04f 0300 	mov.w	r3, #0
  14:	847b      	strh	r3, [r7, #34]	; 0x22
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:183
  uint16_t result = 0x04;
  16:	f04f 0304 	mov.w	r3, #4
  1a:	84bb      	strh	r3, [r7, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:184
  uint32_t pclk1 = 8000000;
  1c:	4b60      	ldr	r3, [pc, #384]	; (1a0 <I2C_Init+0x1a0>)
  1e:	61fb      	str	r3, [r7, #28]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:197
  assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
  assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));

/*---------------------------- I2Cx CR2 Configuration ------------------------*/
  /* Get the I2Cx CR2 value */
  tmpreg = I2Cx->CR2;
  20:	687b      	ldr	r3, [r7, #4]
  22:	889b      	ldrh	r3, [r3, #4]
  24:	84fb      	strh	r3, [r7, #38]	; 0x26
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:199
  /* Clear frequency FREQ[5:0] bits */
  tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
  26:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  28:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
  2c:	84fb      	strh	r3, [r7, #38]	; 0x26
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:201
  /* Get pclk1 frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
  2e:	f107 030c 	add.w	r3, r7, #12
  32:	4618      	mov	r0, r3
  34:	f7ff fffe 	bl	0 <RCC_GetClocksFreq>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:202
  pclk1 = rcc_clocks.PCLK1_Frequency;
  38:	697b      	ldr	r3, [r7, #20]
  3a:	61fb      	str	r3, [r7, #28]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:204
  /* Set frequency bits depending on pclk1 value */
  freqrange = (uint16_t)(pclk1 / 1000000);
  3c:	69fa      	ldr	r2, [r7, #28]
  3e:	4b59      	ldr	r3, [pc, #356]	; (1a4 <I2C_Init+0x1a4>)
  40:	fba3 1302 	umull	r1, r3, r3, r2
  44:	ea4f 4393 	mov.w	r3, r3, lsr #18
  48:	847b      	strh	r3, [r7, #34]	; 0x22
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:205
  tmpreg |= freqrange;
  4a:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
  4c:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
  4e:	ea42 0303 	orr.w	r3, r2, r3
  52:	84fb      	strh	r3, [r7, #38]	; 0x26
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:207
  /* Write to I2Cx CR2 */
  I2Cx->CR2 = tmpreg;
  54:	687b      	ldr	r3, [r7, #4]
  56:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
  58:	809a      	strh	r2, [r3, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:211

/*---------------------------- I2Cx CCR Configuration ------------------------*/
  /* Disable the selected I2C peripheral to configure TRISE */
  I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
  5a:	687b      	ldr	r3, [r7, #4]
  5c:	881b      	ldrh	r3, [r3, #0]
  5e:	b29b      	uxth	r3, r3
  60:	f023 0301 	bic.w	r3, r3, #1
  64:	b29a      	uxth	r2, r3
  66:	687b      	ldr	r3, [r7, #4]
  68:	801a      	strh	r2, [r3, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:214
  /* Reset tmpreg value */
  /* Clear F/S, DUTY and CCR[11:0] bits */
  tmpreg = 0;
  6a:	f04f 0300 	mov.w	r3, #0
  6e:	84fb      	strh	r3, [r7, #38]	; 0x26
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:217

  /* Configure speed in standard mode */
  if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
  70:	683b      	ldr	r3, [r7, #0]
  72:	681a      	ldr	r2, [r3, #0]
  74:	4b4c      	ldr	r3, [pc, #304]	; (1a8 <I2C_Init+0x1a8>)
  76:	429a      	cmp	r2, r3
  78:	d819      	bhi.n	ae <I2C_Init+0xae>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:220
  {
    /* Standard mode speed calculate */
    result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
  7a:	683b      	ldr	r3, [r7, #0]
  7c:	681b      	ldr	r3, [r3, #0]
  7e:	ea4f 0343 	mov.w	r3, r3, lsl #1
  82:	69fa      	ldr	r2, [r7, #28]
  84:	fbb2 f3f3 	udiv	r3, r2, r3
  88:	84bb      	strh	r3, [r7, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:222
    /* Test if CCR value is under 0x4*/
    if (result < 0x04)
  8a:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
  8c:	2b03      	cmp	r3, #3
  8e:	d802      	bhi.n	96 <I2C_Init+0x96>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:225
    {
      /* Set minimum allowed value */
      result = 0x04;  
  90:	f04f 0304 	mov.w	r3, #4
  94:	84bb      	strh	r3, [r7, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:228
    }
    /* Set speed value for standard mode */
    tmpreg |= result;	  
  96:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
  98:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
  9a:	ea42 0303 	orr.w	r3, r2, r3
  9e:	84fb      	strh	r3, [r7, #38]	; 0x26
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:230
    /* Set Maximum Rise Time for standard mode */
    I2Cx->TRISE = freqrange + 1; 
  a0:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
  a2:	f103 0301 	add.w	r3, r3, #1
  a6:	b29a      	uxth	r2, r3
  a8:	687b      	ldr	r3, [r7, #4]
  aa:	841a      	strh	r2, [r3, #32]
  ac:	e049      	b.n	142 <I2C_Init+0x142>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:237
  /* Configure speed in fast mode */
  /* To use the I2C at 400 KHz (in fast mode), the PCLK1 frequency (I2C peripheral
     input clock) must be a multiple of 10 MHz */
  else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
  {
    if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
  ae:	683b      	ldr	r3, [r7, #0]
  b0:	88da      	ldrh	r2, [r3, #6]
  b2:	f64b 73ff 	movw	r3, #49151	; 0xbfff
  b6:	429a      	cmp	r2, r3
  b8:	d10a      	bne.n	d0 <I2C_Init+0xd0>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:240
    {
      /* Fast mode speed calculate: Tlow/Thigh = 2 */
      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
  ba:	683b      	ldr	r3, [r7, #0]
  bc:	681a      	ldr	r2, [r3, #0]
  be:	4613      	mov	r3, r2
  c0:	ea4f 0343 	mov.w	r3, r3, lsl #1
  c4:	189b      	adds	r3, r3, r2
  c6:	69fa      	ldr	r2, [r7, #28]
  c8:	fbb2 f3f3 	udiv	r3, r2, r3
  cc:	84bb      	strh	r3, [r7, #36]	; 0x24
  ce:	e010      	b.n	f2 <I2C_Init+0xf2>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:245
    }
    else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
    {
      /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
  d0:	683b      	ldr	r3, [r7, #0]
  d2:	681a      	ldr	r2, [r3, #0]
  d4:	4613      	mov	r3, r2
  d6:	ea4f 0383 	mov.w	r3, r3, lsl #2
  da:	189b      	adds	r3, r3, r2
  dc:	ea4f 0283 	mov.w	r2, r3, lsl #2
  e0:	189b      	adds	r3, r3, r2
  e2:	69fa      	ldr	r2, [r7, #28]
  e4:	fbb2 f3f3 	udiv	r3, r2, r3
  e8:	84bb      	strh	r3, [r7, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:247
      /* Set DUTY bit */
      result |= I2C_DutyCycle_16_9;
  ea:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
  ec:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  f0:	84bb      	strh	r3, [r7, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:251
    }

    /* Test if CCR value is under 0x1*/
    if ((result & I2C_CCR_CCR) == 0)
  f2:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
  f4:	ea4f 5303 	mov.w	r3, r3, lsl #20
  f8:	ea4f 5313 	mov.w	r3, r3, lsr #20
  fc:	2b00      	cmp	r3, #0
  fe:	d103      	bne.n	108 <I2C_Init+0x108>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:254
    {
      /* Set minimum allowed value */
      result |= (uint16_t)0x0001;  
 100:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 102:	f043 0301 	orr.w	r3, r3, #1
 106:	84bb      	strh	r3, [r7, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:257
    }
    /* Set speed value and set F/S bit for fast mode */
    tmpreg |= (uint16_t)(result | I2C_CCR_FS);
 108:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 10a:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 10c:	ea42 0303 	orr.w	r3, r2, r3
 110:	b29b      	uxth	r3, r3
 112:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 116:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 11a:	84fb      	strh	r3, [r7, #38]	; 0x26
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:259
    /* Set Maximum Rise Time for fast mode */
    I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
 11c:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 11e:	f44f 7296 	mov.w	r2, #300	; 0x12c
 122:	fb02 f303 	mul.w	r3, r2, r3
 126:	4a21      	ldr	r2, [pc, #132]	; (1ac <I2C_Init+0x1ac>)
 128:	fb82 1203 	smull	r1, r2, r2, r3
 12c:	ea4f 12a2 	mov.w	r2, r2, asr #6
 130:	ea4f 73e3 	mov.w	r3, r3, asr #31
 134:	1ad3      	subs	r3, r2, r3
 136:	b29b      	uxth	r3, r3
 138:	f103 0301 	add.w	r3, r3, #1
 13c:	b29a      	uxth	r2, r3
 13e:	687b      	ldr	r3, [r7, #4]
 140:	841a      	strh	r2, [r3, #32]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:263
  }

  /* Write to I2Cx CCR */
  I2Cx->CCR = tmpreg;
 142:	687b      	ldr	r3, [r7, #4]
 144:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 146:	839a      	strh	r2, [r3, #28]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:265
  /* Enable the selected I2C peripheral */
  I2Cx->CR1 |= I2C_CR1_PE;
 148:	687b      	ldr	r3, [r7, #4]
 14a:	881b      	ldrh	r3, [r3, #0]
 14c:	b29b      	uxth	r3, r3
 14e:	f043 0301 	orr.w	r3, r3, #1
 152:	b29a      	uxth	r2, r3
 154:	687b      	ldr	r3, [r7, #4]
 156:	801a      	strh	r2, [r3, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:269

/*---------------------------- I2Cx CR1 Configuration ------------------------*/
  /* Get the I2Cx CR1 value */
  tmpreg = I2Cx->CR1;
 158:	687b      	ldr	r3, [r7, #4]
 15a:	881b      	ldrh	r3, [r3, #0]
 15c:	84fb      	strh	r3, [r7, #38]	; 0x26
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:271
  /* Clear ACK, SMBTYPE and  SMBUS bits */
  tmpreg &= CR1_CLEAR_MASK;
 15e:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 160:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 164:	f023 030a 	bic.w	r3, r3, #10
 168:	84fb      	strh	r3, [r7, #38]	; 0x26
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:275
  /* Configure I2Cx: mode and acknowledgement */
  /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
  /* Set ACK bit according to I2C_Ack value */
  tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
 16a:	683b      	ldr	r3, [r7, #0]
 16c:	889a      	ldrh	r2, [r3, #4]
 16e:	683b      	ldr	r3, [r7, #0]
 170:	895b      	ldrh	r3, [r3, #10]
 172:	ea42 0303 	orr.w	r3, r2, r3
 176:	b29a      	uxth	r2, r3
 178:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 17a:	ea42 0303 	orr.w	r3, r2, r3
 17e:	84fb      	strh	r3, [r7, #38]	; 0x26
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:277
  /* Write to I2Cx CR1 */
  I2Cx->CR1 = tmpreg;
 180:	687b      	ldr	r3, [r7, #4]
 182:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 184:	801a      	strh	r2, [r3, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:281

/*---------------------------- I2Cx OAR1 Configuration -----------------------*/
  /* Set I2Cx Own Address1 and acknowledged address */
  I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
 186:	683b      	ldr	r3, [r7, #0]
 188:	899a      	ldrh	r2, [r3, #12]
 18a:	683b      	ldr	r3, [r7, #0]
 18c:	891b      	ldrh	r3, [r3, #8]
 18e:	ea42 0303 	orr.w	r3, r2, r3
 192:	b29a      	uxth	r2, r3
 194:	687b      	ldr	r3, [r7, #4]
 196:	811a      	strh	r2, [r3, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:282
}
 198:	f107 0728 	add.w	r7, r7, #40	; 0x28
 19c:	46bd      	mov	sp, r7
 19e:	bd80      	pop	{r7, pc}
 1a0:	007a1200 	.word	0x007a1200
 1a4:	431bde83 	.word	0x431bde83
 1a8:	000186a0 	.word	0x000186a0
 1ac:	10624dd3 	.word	0x10624dd3

Disassembly of section .text.I2C_StructInit:

00000000 <I2C_StructInit>:
I2C_StructInit():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:290
  * @brief  Fills each I2C_InitStruct member with its default value.
  * @param  I2C_InitStruct: pointer to an I2C_InitTypeDef structure which will be initialized.
  * @retval None
  */
void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:293
/*---------------- Reset I2C init structure parameters values ----------------*/
  /* initialize the I2C_ClockSpeed member */
  I2C_InitStruct->I2C_ClockSpeed = 5000;
   8:	687b      	ldr	r3, [r7, #4]
   a:	f241 3288 	movw	r2, #5000	; 0x1388
   e:	601a      	str	r2, [r3, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:295
  /* Initialize the I2C_Mode member */
  I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
  10:	687b      	ldr	r3, [r7, #4]
  12:	f04f 0200 	mov.w	r2, #0
  16:	809a      	strh	r2, [r3, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:297
  /* Initialize the I2C_DutyCycle member */
  I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
  18:	687b      	ldr	r3, [r7, #4]
  1a:	f64b 72ff 	movw	r2, #49151	; 0xbfff
  1e:	80da      	strh	r2, [r3, #6]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:299
  /* Initialize the I2C_OwnAddress1 member */
  I2C_InitStruct->I2C_OwnAddress1 = 0;
  20:	687b      	ldr	r3, [r7, #4]
  22:	f04f 0200 	mov.w	r2, #0
  26:	811a      	strh	r2, [r3, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:301
  /* Initialize the I2C_Ack member */
  I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
  28:	687b      	ldr	r3, [r7, #4]
  2a:	f04f 0200 	mov.w	r2, #0
  2e:	815a      	strh	r2, [r3, #10]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:303
  /* Initialize the I2C_AcknowledgedAddress member */
  I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
  30:	687b      	ldr	r3, [r7, #4]
  32:	f44f 4280 	mov.w	r2, #16384	; 0x4000
  36:	819a      	strh	r2, [r3, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:304
}
  38:	f107 070c 	add.w	r7, r7, #12
  3c:	46bd      	mov	sp, r7
  3e:	bc80      	pop	{r7}
  40:	4770      	bx	lr
  42:	bf00      	nop

Disassembly of section .text.I2C_Cmd:

00000000 <I2C_Cmd>:
I2C_Cmd():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:314
  * @param  NewState: new state of the I2Cx peripheral. 
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	70fb      	strb	r3, [r7, #3]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:318
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   c:	78fb      	ldrb	r3, [r7, #3]
   e:	2b00      	cmp	r3, #0
  10:	d008      	beq.n	24 <I2C_Cmd+0x24>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:321
  {
    /* Enable the selected I2C peripheral */
    I2Cx->CR1 |= I2C_CR1_PE;
  12:	687b      	ldr	r3, [r7, #4]
  14:	881b      	ldrh	r3, [r3, #0]
  16:	b29b      	uxth	r3, r3
  18:	f043 0301 	orr.w	r3, r3, #1
  1c:	b29a      	uxth	r2, r3
  1e:	687b      	ldr	r3, [r7, #4]
  20:	801a      	strh	r2, [r3, #0]
  22:	e007      	b.n	34 <I2C_Cmd+0x34>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:326
  }
  else
  {
    /* Disable the selected I2C peripheral */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
  24:	687b      	ldr	r3, [r7, #4]
  26:	881b      	ldrh	r3, [r3, #0]
  28:	b29b      	uxth	r3, r3
  2a:	f023 0301 	bic.w	r3, r3, #1
  2e:	b29a      	uxth	r2, r3
  30:	687b      	ldr	r3, [r7, #4]
  32:	801a      	strh	r2, [r3, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:328
  }
}
  34:	f107 070c 	add.w	r7, r7, #12
  38:	46bd      	mov	sp, r7
  3a:	bc80      	pop	{r7}
  3c:	4770      	bx	lr
  3e:	bf00      	nop

Disassembly of section .text.I2C_AnalogFilterCmd:

00000000 <I2C_AnalogFilterCmd>:
I2C_AnalogFilterCmd():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:343
  * @note   This function should be called before initializing and enabling
            the I2C Peripheral.
  * @retval None
  */
void I2C_AnalogFilterCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	70fb      	strb	r3, [r7, #3]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:347
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   c:	78fb      	ldrb	r3, [r7, #3]
   e:	2b00      	cmp	r3, #0
  10:	d008      	beq.n	24 <I2C_AnalogFilterCmd+0x24>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:350
  {
    /* Enable the analog filter */
    I2Cx->FLTR &= (uint16_t)~((uint16_t)I2C_FLTR_ANOFF);    
  12:	687b      	ldr	r3, [r7, #4]
  14:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  16:	b29b      	uxth	r3, r3
  18:	f023 0310 	bic.w	r3, r3, #16
  1c:	b29a      	uxth	r2, r3
  1e:	687b      	ldr	r3, [r7, #4]
  20:	849a      	strh	r2, [r3, #36]	; 0x24
  22:	e007      	b.n	34 <I2C_AnalogFilterCmd+0x34>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:355
  }
  else
  {
    /* Disable the analog filter */
    I2Cx->FLTR |= I2C_FLTR_ANOFF;
  24:	687b      	ldr	r3, [r7, #4]
  26:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  28:	b29b      	uxth	r3, r3
  2a:	f043 0310 	orr.w	r3, r3, #16
  2e:	b29a      	uxth	r2, r3
  30:	687b      	ldr	r3, [r7, #4]
  32:	849a      	strh	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:357
  }
}
  34:	f107 070c 	add.w	r7, r7, #12
  38:	46bd      	mov	sp, r7
  3a:	bc80      	pop	{r7}
  3c:	4770      	bx	lr
  3e:	bf00      	nop

Disassembly of section .text.I2C_DigitalFilterConfig:

00000000 <I2C_DigitalFilterConfig>:
I2C_DigitalFilterConfig():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:372
  * @note   This function should be called before initializing and enabling
            the I2C Peripheral.
  * @retval None
  */
void I2C_DigitalFilterConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DigitalFilter)
{
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	807b      	strh	r3, [r7, #2]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:373
  uint16_t tmpreg = 0;
   c:	f04f 0300 	mov.w	r3, #0
  10:	81fb      	strh	r3, [r7, #14]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:380
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_DIGITAL_FILTER(I2C_DigitalFilter));
  
  /* Get the old register value */
  tmpreg = I2Cx->FLTR;
  12:	687b      	ldr	r3, [r7, #4]
  14:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  16:	81fb      	strh	r3, [r7, #14]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:383
  
  /* Reset I2Cx DNF bit [3:0] */
  tmpreg &= (uint16_t)~((uint16_t)I2C_FLTR_DNF);
  18:	89fb      	ldrh	r3, [r7, #14]
  1a:	f023 030f 	bic.w	r3, r3, #15
  1e:	81fb      	strh	r3, [r7, #14]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:386
  
  /* Set I2Cx DNF coefficient */
  tmpreg |= (uint16_t)((uint16_t)I2C_DigitalFilter & I2C_FLTR_DNF);
  20:	887b      	ldrh	r3, [r7, #2]
  22:	f003 030f 	and.w	r3, r3, #15
  26:	b29a      	uxth	r2, r3
  28:	89fb      	ldrh	r3, [r7, #14]
  2a:	ea42 0303 	orr.w	r3, r2, r3
  2e:	b29b      	uxth	r3, r3
  30:	81fb      	strh	r3, [r7, #14]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:389
  
  /* Store the new register value */
  I2Cx->FLTR = tmpreg;
  32:	687b      	ldr	r3, [r7, #4]
  34:	89fa      	ldrh	r2, [r7, #14]
  36:	849a      	strh	r2, [r3, #36]	; 0x24
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:390
}
  38:	f107 0714 	add.w	r7, r7, #20
  3c:	46bd      	mov	sp, r7
  3e:	bc80      	pop	{r7}
  40:	4770      	bx	lr
  42:	bf00      	nop

Disassembly of section .text.I2C_GenerateSTART:

00000000 <I2C_GenerateSTART>:
I2C_GenerateSTART():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:400
  * @param  NewState: new state of the I2C START condition generation.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None.
  */
void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	70fb      	strb	r3, [r7, #3]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:404
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   c:	78fb      	ldrb	r3, [r7, #3]
   e:	2b00      	cmp	r3, #0
  10:	d008      	beq.n	24 <I2C_GenerateSTART+0x24>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:407
  {
    /* Generate a START condition */
    I2Cx->CR1 |= I2C_CR1_START;
  12:	687b      	ldr	r3, [r7, #4]
  14:	881b      	ldrh	r3, [r3, #0]
  16:	b29b      	uxth	r3, r3
  18:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  1c:	b29a      	uxth	r2, r3
  1e:	687b      	ldr	r3, [r7, #4]
  20:	801a      	strh	r2, [r3, #0]
  22:	e007      	b.n	34 <I2C_GenerateSTART+0x34>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:412
  }
  else
  {
    /* Disable the START condition generation */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_START);
  24:	687b      	ldr	r3, [r7, #4]
  26:	881b      	ldrh	r3, [r3, #0]
  28:	b29b      	uxth	r3, r3
  2a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  2e:	b29a      	uxth	r2, r3
  30:	687b      	ldr	r3, [r7, #4]
  32:	801a      	strh	r2, [r3, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:414
  }
}
  34:	f107 070c 	add.w	r7, r7, #12
  38:	46bd      	mov	sp, r7
  3a:	bc80      	pop	{r7}
  3c:	4770      	bx	lr
  3e:	bf00      	nop

Disassembly of section .text.I2C_GenerateSTOP:

00000000 <I2C_GenerateSTOP>:
I2C_GenerateSTOP():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:424
  * @param  NewState: new state of the I2C STOP condition generation.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None.
  */
void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	70fb      	strb	r3, [r7, #3]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:428
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   c:	78fb      	ldrb	r3, [r7, #3]
   e:	2b00      	cmp	r3, #0
  10:	d008      	beq.n	24 <I2C_GenerateSTOP+0x24>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:431
  {
    /* Generate a STOP condition */
    I2Cx->CR1 |= I2C_CR1_STOP;
  12:	687b      	ldr	r3, [r7, #4]
  14:	881b      	ldrh	r3, [r3, #0]
  16:	b29b      	uxth	r3, r3
  18:	f443 7300 	orr.w	r3, r3, #512	; 0x200
  1c:	b29a      	uxth	r2, r3
  1e:	687b      	ldr	r3, [r7, #4]
  20:	801a      	strh	r2, [r3, #0]
  22:	e007      	b.n	34 <I2C_GenerateSTOP+0x34>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:436
  }
  else
  {
    /* Disable the STOP condition generation */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_STOP);
  24:	687b      	ldr	r3, [r7, #4]
  26:	881b      	ldrh	r3, [r3, #0]
  28:	b29b      	uxth	r3, r3
  2a:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  2e:	b29a      	uxth	r2, r3
  30:	687b      	ldr	r3, [r7, #4]
  32:	801a      	strh	r2, [r3, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:438
  }
}
  34:	f107 070c 	add.w	r7, r7, #12
  38:	46bd      	mov	sp, r7
  3a:	bc80      	pop	{r7}
  3c:	4770      	bx	lr
  3e:	bf00      	nop

Disassembly of section .text.I2C_Send7bitAddress:

00000000 <I2C_Send7bitAddress>:
I2C_Send7bitAddress():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:452
  *            @arg I2C_Direction_Transmitter: Transmitter mode
  *            @arg I2C_Direction_Receiver: Receiver mode
  * @retval None.
  */
void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	4613      	mov	r3, r2
   a:	460a      	mov	r2, r1
   c:	70fa      	strb	r2, [r7, #3]
   e:	70bb      	strb	r3, [r7, #2]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:457
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_DIRECTION(I2C_Direction));
  /* Test on the direction to set/reset the read/write bit */
  if (I2C_Direction != I2C_Direction_Transmitter)
  10:	78bb      	ldrb	r3, [r7, #2]
  12:	2b00      	cmp	r3, #0
  14:	d004      	beq.n	20 <I2C_Send7bitAddress+0x20>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:460
  {
    /* Set the address bit0 for read */
    Address |= I2C_OAR1_ADD0;
  16:	78fb      	ldrb	r3, [r7, #3]
  18:	f043 0301 	orr.w	r3, r3, #1
  1c:	70fb      	strb	r3, [r7, #3]
  1e:	e003      	b.n	28 <I2C_Send7bitAddress+0x28>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:465
  }
  else
  {
    /* Reset the address bit0 for write */
    Address &= (uint8_t)~((uint8_t)I2C_OAR1_ADD0);
  20:	78fb      	ldrb	r3, [r7, #3]
  22:	f023 0301 	bic.w	r3, r3, #1
  26:	70fb      	strb	r3, [r7, #3]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:468
  }
  /* Send the address */
  I2Cx->DR = Address;
  28:	78fb      	ldrb	r3, [r7, #3]
  2a:	b29a      	uxth	r2, r3
  2c:	687b      	ldr	r3, [r7, #4]
  2e:	821a      	strh	r2, [r3, #16]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:469
}
  30:	f107 070c 	add.w	r7, r7, #12
  34:	46bd      	mov	sp, r7
  36:	bc80      	pop	{r7}
  38:	4770      	bx	lr
  3a:	bf00      	nop

Disassembly of section .text.I2C_AcknowledgeConfig:

00000000 <I2C_AcknowledgeConfig>:
I2C_AcknowledgeConfig():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:479
  * @param  NewState: new state of the I2C Acknowledgement.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None.
  */
void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	70fb      	strb	r3, [r7, #3]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:483
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   c:	78fb      	ldrb	r3, [r7, #3]
   e:	2b00      	cmp	r3, #0
  10:	d008      	beq.n	24 <I2C_AcknowledgeConfig+0x24>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:486
  {
    /* Enable the acknowledgement */
    I2Cx->CR1 |= I2C_CR1_ACK;
  12:	687b      	ldr	r3, [r7, #4]
  14:	881b      	ldrh	r3, [r3, #0]
  16:	b29b      	uxth	r3, r3
  18:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
  1c:	b29a      	uxth	r2, r3
  1e:	687b      	ldr	r3, [r7, #4]
  20:	801a      	strh	r2, [r3, #0]
  22:	e007      	b.n	34 <I2C_AcknowledgeConfig+0x34>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:491
  }
  else
  {
    /* Disable the acknowledgement */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ACK);
  24:	687b      	ldr	r3, [r7, #4]
  26:	881b      	ldrh	r3, [r3, #0]
  28:	b29b      	uxth	r3, r3
  2a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
  2e:	b29a      	uxth	r2, r3
  30:	687b      	ldr	r3, [r7, #4]
  32:	801a      	strh	r2, [r3, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:493
  }
}
  34:	f107 070c 	add.w	r7, r7, #12
  38:	46bd      	mov	sp, r7
  3a:	bc80      	pop	{r7}
  3c:	4770      	bx	lr
  3e:	bf00      	nop

Disassembly of section .text.I2C_OwnAddress2Config:

00000000 <I2C_OwnAddress2Config>:
I2C_OwnAddress2Config():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:502
  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
  * @param  Address: specifies the 7bit I2C own address2.
  * @retval None.
  */
void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address)
{
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	70fb      	strb	r3, [r7, #3]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:503
  uint16_t tmpreg = 0;
   c:	f04f 0300 	mov.w	r3, #0
  10:	81fb      	strh	r3, [r7, #14]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:509

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Get the old register value */
  tmpreg = I2Cx->OAR2;
  12:	687b      	ldr	r3, [r7, #4]
  14:	899b      	ldrh	r3, [r3, #12]
  16:	81fb      	strh	r3, [r7, #14]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:512

  /* Reset I2Cx Own address2 bit [7:1] */
  tmpreg &= (uint16_t)~((uint16_t)I2C_OAR2_ADD2);
  18:	89fb      	ldrh	r3, [r7, #14]
  1a:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
  1e:	81fb      	strh	r3, [r7, #14]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:515

  /* Set I2Cx Own address2 */
  tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
  20:	78fb      	ldrb	r3, [r7, #3]
  22:	b29b      	uxth	r3, r3
  24:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
  28:	b29a      	uxth	r2, r3
  2a:	89fb      	ldrh	r3, [r7, #14]
  2c:	ea42 0303 	orr.w	r3, r2, r3
  30:	b29b      	uxth	r3, r3
  32:	81fb      	strh	r3, [r7, #14]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:518

  /* Store the new register value */
  I2Cx->OAR2 = tmpreg;
  34:	687b      	ldr	r3, [r7, #4]
  36:	89fa      	ldrh	r2, [r7, #14]
  38:	819a      	strh	r2, [r3, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:519
}
  3a:	f107 0714 	add.w	r7, r7, #20
  3e:	46bd      	mov	sp, r7
  40:	bc80      	pop	{r7}
  42:	4770      	bx	lr

Disassembly of section .text.I2C_DualAddressCmd:

00000000 <I2C_DualAddressCmd>:
I2C_DualAddressCmd():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:529
  * @param  NewState: new state of the I2C dual addressing mode.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	70fb      	strb	r3, [r7, #3]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:533
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   c:	78fb      	ldrb	r3, [r7, #3]
   e:	2b00      	cmp	r3, #0
  10:	d008      	beq.n	24 <I2C_DualAddressCmd+0x24>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:536
  {
    /* Enable dual addressing mode */
    I2Cx->OAR2 |= I2C_OAR2_ENDUAL;
  12:	687b      	ldr	r3, [r7, #4]
  14:	899b      	ldrh	r3, [r3, #12]
  16:	b29b      	uxth	r3, r3
  18:	f043 0301 	orr.w	r3, r3, #1
  1c:	b29a      	uxth	r2, r3
  1e:	687b      	ldr	r3, [r7, #4]
  20:	819a      	strh	r2, [r3, #12]
  22:	e007      	b.n	34 <I2C_DualAddressCmd+0x34>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:541
  }
  else
  {
    /* Disable dual addressing mode */
    I2Cx->OAR2 &= (uint16_t)~((uint16_t)I2C_OAR2_ENDUAL);
  24:	687b      	ldr	r3, [r7, #4]
  26:	899b      	ldrh	r3, [r3, #12]
  28:	b29b      	uxth	r3, r3
  2a:	f023 0301 	bic.w	r3, r3, #1
  2e:	b29a      	uxth	r2, r3
  30:	687b      	ldr	r3, [r7, #4]
  32:	819a      	strh	r2, [r3, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:543
  }
}
  34:	f107 070c 	add.w	r7, r7, #12
  38:	46bd      	mov	sp, r7
  3a:	bc80      	pop	{r7}
  3c:	4770      	bx	lr
  3e:	bf00      	nop

Disassembly of section .text.I2C_GeneralCallCmd:

00000000 <I2C_GeneralCallCmd>:
I2C_GeneralCallCmd():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:553
  * @param  NewState: new state of the I2C General call.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	70fb      	strb	r3, [r7, #3]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:557
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   c:	78fb      	ldrb	r3, [r7, #3]
   e:	2b00      	cmp	r3, #0
  10:	d008      	beq.n	24 <I2C_GeneralCallCmd+0x24>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:560
  {
    /* Enable generall call */
    I2Cx->CR1 |= I2C_CR1_ENGC;
  12:	687b      	ldr	r3, [r7, #4]
  14:	881b      	ldrh	r3, [r3, #0]
  16:	b29b      	uxth	r3, r3
  18:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  1c:	b29a      	uxth	r2, r3
  1e:	687b      	ldr	r3, [r7, #4]
  20:	801a      	strh	r2, [r3, #0]
  22:	e007      	b.n	34 <I2C_GeneralCallCmd+0x34>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:565
  }
  else
  {
    /* Disable generall call */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENGC);
  24:	687b      	ldr	r3, [r7, #4]
  26:	881b      	ldrh	r3, [r3, #0]
  28:	b29b      	uxth	r3, r3
  2a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  2e:	b29a      	uxth	r2, r3
  30:	687b      	ldr	r3, [r7, #4]
  32:	801a      	strh	r2, [r3, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:567
  }
}
  34:	f107 070c 	add.w	r7, r7, #12
  38:	46bd      	mov	sp, r7
  3a:	bc80      	pop	{r7}
  3c:	4770      	bx	lr
  3e:	bf00      	nop

Disassembly of section .text.I2C_SoftwareResetCmd:

00000000 <I2C_SoftwareResetCmd>:
I2C_SoftwareResetCmd():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:579
  * @param  NewState: new state of the I2C software reset.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	70fb      	strb	r3, [r7, #3]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:583
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   c:	78fb      	ldrb	r3, [r7, #3]
   e:	2b00      	cmp	r3, #0
  10:	d00a      	beq.n	28 <I2C_SoftwareResetCmd+0x28>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:586
  {
    /* Peripheral under reset */
    I2Cx->CR1 |= I2C_CR1_SWRST;
  12:	687b      	ldr	r3, [r7, #4]
  14:	881b      	ldrh	r3, [r3, #0]
  16:	b29b      	uxth	r3, r3
  18:	ea6f 4343 	mvn.w	r3, r3, lsl #17
  1c:	ea6f 4353 	mvn.w	r3, r3, lsr #17
  20:	b29a      	uxth	r2, r3
  22:	687b      	ldr	r3, [r7, #4]
  24:	801a      	strh	r2, [r3, #0]
  26:	e009      	b.n	3c <I2C_SoftwareResetCmd+0x3c>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:591
  }
  else
  {
    /* Peripheral not under reset */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_SWRST);
  28:	687b      	ldr	r3, [r7, #4]
  2a:	881b      	ldrh	r3, [r3, #0]
  2c:	b29b      	uxth	r3, r3
  2e:	ea4f 4343 	mov.w	r3, r3, lsl #17
  32:	ea4f 4353 	mov.w	r3, r3, lsr #17
  36:	b29a      	uxth	r2, r3
  38:	687b      	ldr	r3, [r7, #4]
  3a:	801a      	strh	r2, [r3, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:593
  }
}
  3c:	f107 070c 	add.w	r7, r7, #12
  40:	46bd      	mov	sp, r7
  42:	bc80      	pop	{r7}
  44:	4770      	bx	lr
  46:	bf00      	nop

Disassembly of section .text.I2C_StretchClockCmd:

00000000 <I2C_StretchClockCmd>:
I2C_StretchClockCmd():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:603
  * @param  NewState: new state of the I2Cx Clock stretching.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	70fb      	strb	r3, [r7, #3]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:607
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState == DISABLE)
   c:	78fb      	ldrb	r3, [r7, #3]
   e:	2b00      	cmp	r3, #0
  10:	d108      	bne.n	24 <I2C_StretchClockCmd+0x24>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:610
  {
    /* Enable the selected I2C Clock stretching */
    I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
  12:	687b      	ldr	r3, [r7, #4]
  14:	881b      	ldrh	r3, [r3, #0]
  16:	b29b      	uxth	r3, r3
  18:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  1c:	b29a      	uxth	r2, r3
  1e:	687b      	ldr	r3, [r7, #4]
  20:	801a      	strh	r2, [r3, #0]
  22:	e007      	b.n	34 <I2C_StretchClockCmd+0x34>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:615
  }
  else
  {
    /* Disable the selected I2C Clock stretching */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_NOSTRETCH);
  24:	687b      	ldr	r3, [r7, #4]
  26:	881b      	ldrh	r3, [r3, #0]
  28:	b29b      	uxth	r3, r3
  2a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  2e:	b29a      	uxth	r2, r3
  30:	687b      	ldr	r3, [r7, #4]
  32:	801a      	strh	r2, [r3, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:617
  }
}
  34:	f107 070c 	add.w	r7, r7, #12
  38:	46bd      	mov	sp, r7
  3a:	bc80      	pop	{r7}
  3c:	4770      	bx	lr
  3e:	bf00      	nop

Disassembly of section .text.I2C_FastModeDutyCycleConfig:

00000000 <I2C_FastModeDutyCycleConfig>:
I2C_FastModeDutyCycleConfig():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:629
  *            @arg I2C_DutyCycle_2: I2C fast mode Tlow/Thigh = 2
  *            @arg I2C_DutyCycle_16_9: I2C fast mode Tlow/Thigh = 16/9
  * @retval None
  */
void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	807b      	strh	r3, [r7, #2]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:633
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
  if (I2C_DutyCycle != I2C_DutyCycle_16_9)
   c:	887b      	ldrh	r3, [r7, #2]
   e:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
  12:	d008      	beq.n	26 <I2C_FastModeDutyCycleConfig+0x26>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:636
  {
    /* I2C fast mode Tlow/Thigh=2 */
    I2Cx->CCR &= I2C_DutyCycle_2;
  14:	687b      	ldr	r3, [r7, #4]
  16:	8b9b      	ldrh	r3, [r3, #28]
  18:	b29b      	uxth	r3, r3
  1a:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
  1e:	b29a      	uxth	r2, r3
  20:	687b      	ldr	r3, [r7, #4]
  22:	839a      	strh	r2, [r3, #28]
  24:	e007      	b.n	36 <I2C_FastModeDutyCycleConfig+0x36>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:641
  }
  else
  {
    /* I2C fast mode Tlow/Thigh=16/9 */
    I2Cx->CCR |= I2C_DutyCycle_16_9;
  26:	687b      	ldr	r3, [r7, #4]
  28:	8b9b      	ldrh	r3, [r3, #28]
  2a:	b29b      	uxth	r3, r3
  2c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  30:	b29a      	uxth	r2, r3
  32:	687b      	ldr	r3, [r7, #4]
  34:	839a      	strh	r2, [r3, #28]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:643
  }
}
  36:	f107 070c 	add.w	r7, r7, #12
  3a:	46bd      	mov	sp, r7
  3c:	bc80      	pop	{r7}
  3e:	4770      	bx	lr

Disassembly of section .text.I2C_NACKPositionConfig:

00000000 <I2C_NACKPositionConfig>:
I2C_NACKPositionConfig():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:667
  *          is intended to used in SMBUS mode. 
  *            
  * @retval None
  */
void I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	807b      	strh	r3, [r7, #2]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:673
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_NACK_POSITION(I2C_NACKPosition));
  
  /* Check the input parameter */
  if (I2C_NACKPosition == I2C_NACKPosition_Next)
   c:	887b      	ldrh	r3, [r7, #2]
   e:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
  12:	d108      	bne.n	26 <I2C_NACKPositionConfig+0x26>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:676
  {
    /* Next byte in shift register is the last received byte */
    I2Cx->CR1 |= I2C_NACKPosition_Next;
  14:	687b      	ldr	r3, [r7, #4]
  16:	881b      	ldrh	r3, [r3, #0]
  18:	b29b      	uxth	r3, r3
  1a:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
  1e:	b29a      	uxth	r2, r3
  20:	687b      	ldr	r3, [r7, #4]
  22:	801a      	strh	r2, [r3, #0]
  24:	e007      	b.n	36 <I2C_NACKPositionConfig+0x36>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:681
  }
  else
  {
    /* Current byte in shift register is the last received byte */
    I2Cx->CR1 &= I2C_NACKPosition_Current;
  26:	687b      	ldr	r3, [r7, #4]
  28:	881b      	ldrh	r3, [r3, #0]
  2a:	b29b      	uxth	r3, r3
  2c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
  30:	b29a      	uxth	r2, r3
  32:	687b      	ldr	r3, [r7, #4]
  34:	801a      	strh	r2, [r3, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:683
  }
}
  36:	f107 070c 	add.w	r7, r7, #12
  3a:	46bd      	mov	sp, r7
  3c:	bc80      	pop	{r7}
  3e:	4770      	bx	lr

Disassembly of section .text.I2C_SMBusAlertConfig:

00000000 <I2C_SMBusAlertConfig>:
I2C_SMBusAlertConfig():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:695
  *            @arg I2C_SMBusAlert_Low: SMBAlert pin driven low
  *            @arg I2C_SMBusAlert_High: SMBAlert pin driven high
  * @retval None
  */
void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	807b      	strh	r3, [r7, #2]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:699
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
  if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
   c:	887b      	ldrh	r3, [r7, #2]
   e:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
  12:	d108      	bne.n	26 <I2C_SMBusAlertConfig+0x26>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:702
  {
    /* Drive the SMBusAlert pin Low */
    I2Cx->CR1 |= I2C_SMBusAlert_Low;
  14:	687b      	ldr	r3, [r7, #4]
  16:	881b      	ldrh	r3, [r3, #0]
  18:	b29b      	uxth	r3, r3
  1a:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
  1e:	b29a      	uxth	r2, r3
  20:	687b      	ldr	r3, [r7, #4]
  22:	801a      	strh	r2, [r3, #0]
  24:	e007      	b.n	36 <I2C_SMBusAlertConfig+0x36>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:707
  }
  else
  {
    /* Drive the SMBusAlert pin High  */
    I2Cx->CR1 &= I2C_SMBusAlert_High;
  26:	687b      	ldr	r3, [r7, #4]
  28:	881b      	ldrh	r3, [r3, #0]
  2a:	b29b      	uxth	r3, r3
  2c:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  30:	b29a      	uxth	r2, r3
  32:	687b      	ldr	r3, [r7, #4]
  34:	801a      	strh	r2, [r3, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:709
  }
}
  36:	f107 070c 	add.w	r7, r7, #12
  3a:	46bd      	mov	sp, r7
  3c:	bc80      	pop	{r7}
  3e:	4770      	bx	lr

Disassembly of section .text.I2C_ARPCmd:

00000000 <I2C_ARPCmd>:
I2C_ARPCmd():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:719
  * @param  NewState: new state of the I2Cx ARP. 
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	70fb      	strb	r3, [r7, #3]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:723
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   c:	78fb      	ldrb	r3, [r7, #3]
   e:	2b00      	cmp	r3, #0
  10:	d008      	beq.n	24 <I2C_ARPCmd+0x24>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:726
  {
    /* Enable the selected I2C ARP */
    I2Cx->CR1 |= I2C_CR1_ENARP;
  12:	687b      	ldr	r3, [r7, #4]
  14:	881b      	ldrh	r3, [r3, #0]
  16:	b29b      	uxth	r3, r3
  18:	f043 0310 	orr.w	r3, r3, #16
  1c:	b29a      	uxth	r2, r3
  1e:	687b      	ldr	r3, [r7, #4]
  20:	801a      	strh	r2, [r3, #0]
  22:	e007      	b.n	34 <I2C_ARPCmd+0x34>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:731
  }
  else
  {
    /* Disable the selected I2C ARP */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENARP);
  24:	687b      	ldr	r3, [r7, #4]
  26:	881b      	ldrh	r3, [r3, #0]
  28:	b29b      	uxth	r3, r3
  2a:	f023 0310 	bic.w	r3, r3, #16
  2e:	b29a      	uxth	r2, r3
  30:	687b      	ldr	r3, [r7, #4]
  32:	801a      	strh	r2, [r3, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:733
  }
}
  34:	f107 070c 	add.w	r7, r7, #12
  38:	46bd      	mov	sp, r7
  3a:	bc80      	pop	{r7}
  3c:	4770      	bx	lr
  3e:	bf00      	nop

Disassembly of section .text.I2C_SendData:

00000000 <I2C_SendData>:
I2C_SendData():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:757
  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
  * @param  Data: Byte to be transmitted..
  * @retval None
  */
void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	70fb      	strb	r3, [r7, #3]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:761
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Write in the DR register the data to be sent */
  I2Cx->DR = Data;
   c:	78fb      	ldrb	r3, [r7, #3]
   e:	b29a      	uxth	r2, r3
  10:	687b      	ldr	r3, [r7, #4]
  12:	821a      	strh	r2, [r3, #16]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:762
}
  14:	f107 070c 	add.w	r7, r7, #12
  18:	46bd      	mov	sp, r7
  1a:	bc80      	pop	{r7}
  1c:	4770      	bx	lr
  1e:	bf00      	nop

Disassembly of section .text.I2C_ReceiveData:

00000000 <I2C_ReceiveData>:
I2C_ReceiveData():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:770
  * @brief  Returns the most recent received data by the I2Cx peripheral.
  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
  * @retval The value of the received data.
  */
uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:774
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Return the data in the DR register */
  return (uint8_t)I2Cx->DR;
   8:	687b      	ldr	r3, [r7, #4]
   a:	8a1b      	ldrh	r3, [r3, #16]
   c:	b29b      	uxth	r3, r3
   e:	b2db      	uxtb	r3, r3
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:775
}
  10:	4618      	mov	r0, r3
  12:	f107 070c 	add.w	r7, r7, #12
  16:	46bd      	mov	sp, r7
  18:	bc80      	pop	{r7}
  1a:	4770      	bx	lr

Disassembly of section .text.I2C_TransmitPEC:

00000000 <I2C_TransmitPEC>:
I2C_TransmitPEC():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:801
  * @param  NewState: new state of the I2C PEC transmission.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	70fb      	strb	r3, [r7, #3]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:805
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   c:	78fb      	ldrb	r3, [r7, #3]
   e:	2b00      	cmp	r3, #0
  10:	d008      	beq.n	24 <I2C_TransmitPEC+0x24>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:808
  {
    /* Enable the selected I2C PEC transmission */
    I2Cx->CR1 |= I2C_CR1_PEC;
  12:	687b      	ldr	r3, [r7, #4]
  14:	881b      	ldrh	r3, [r3, #0]
  16:	b29b      	uxth	r3, r3
  18:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
  1c:	b29a      	uxth	r2, r3
  1e:	687b      	ldr	r3, [r7, #4]
  20:	801a      	strh	r2, [r3, #0]
  22:	e007      	b.n	34 <I2C_TransmitPEC+0x34>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:813
  }
  else
  {
    /* Disable the selected I2C PEC transmission */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PEC);
  24:	687b      	ldr	r3, [r7, #4]
  26:	881b      	ldrh	r3, [r3, #0]
  28:	b29b      	uxth	r3, r3
  2a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  2e:	b29a      	uxth	r2, r3
  30:	687b      	ldr	r3, [r7, #4]
  32:	801a      	strh	r2, [r3, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:815
  }
}
  34:	f107 070c 	add.w	r7, r7, #12
  38:	46bd      	mov	sp, r7
  3a:	bc80      	pop	{r7}
  3c:	4770      	bx	lr
  3e:	bf00      	nop

Disassembly of section .text.I2C_PECPositionConfig:

00000000 <I2C_PECPositionConfig>:
I2C_PECPositionConfig():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:832
  *          is intended to used in I2C mode.
  *                
  * @retval None
  */
void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	807b      	strh	r3, [r7, #2]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:836
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
  if (I2C_PECPosition == I2C_PECPosition_Next)
   c:	887b      	ldrh	r3, [r7, #2]
   e:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
  12:	d108      	bne.n	26 <I2C_PECPositionConfig+0x26>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:839
  {
    /* Next byte in shift register is PEC */
    I2Cx->CR1 |= I2C_PECPosition_Next;
  14:	687b      	ldr	r3, [r7, #4]
  16:	881b      	ldrh	r3, [r3, #0]
  18:	b29b      	uxth	r3, r3
  1a:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
  1e:	b29a      	uxth	r2, r3
  20:	687b      	ldr	r3, [r7, #4]
  22:	801a      	strh	r2, [r3, #0]
  24:	e007      	b.n	36 <I2C_PECPositionConfig+0x36>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:844
  }
  else
  {
    /* Current byte in shift register is PEC */
    I2Cx->CR1 &= I2C_PECPosition_Current;
  26:	687b      	ldr	r3, [r7, #4]
  28:	881b      	ldrh	r3, [r3, #0]
  2a:	b29b      	uxth	r3, r3
  2c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
  30:	b29a      	uxth	r2, r3
  32:	687b      	ldr	r3, [r7, #4]
  34:	801a      	strh	r2, [r3, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:846
  }
}
  36:	f107 070c 	add.w	r7, r7, #12
  3a:	46bd      	mov	sp, r7
  3c:	bc80      	pop	{r7}
  3e:	4770      	bx	lr

Disassembly of section .text.I2C_CalculatePEC:

00000000 <I2C_CalculatePEC>:
I2C_CalculatePEC():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:856
  * @param  NewState: new state of the I2Cx PEC value calculation.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	70fb      	strb	r3, [r7, #3]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:860
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   c:	78fb      	ldrb	r3, [r7, #3]
   e:	2b00      	cmp	r3, #0
  10:	d008      	beq.n	24 <I2C_CalculatePEC+0x24>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:863
  {
    /* Enable the selected I2C PEC calculation */
    I2Cx->CR1 |= I2C_CR1_ENPEC;
  12:	687b      	ldr	r3, [r7, #4]
  14:	881b      	ldrh	r3, [r3, #0]
  16:	b29b      	uxth	r3, r3
  18:	f043 0320 	orr.w	r3, r3, #32
  1c:	b29a      	uxth	r2, r3
  1e:	687b      	ldr	r3, [r7, #4]
  20:	801a      	strh	r2, [r3, #0]
  22:	e007      	b.n	34 <I2C_CalculatePEC+0x34>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:868
  }
  else
  {
    /* Disable the selected I2C PEC calculation */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENPEC);
  24:	687b      	ldr	r3, [r7, #4]
  26:	881b      	ldrh	r3, [r3, #0]
  28:	b29b      	uxth	r3, r3
  2a:	f023 0320 	bic.w	r3, r3, #32
  2e:	b29a      	uxth	r2, r3
  30:	687b      	ldr	r3, [r7, #4]
  32:	801a      	strh	r2, [r3, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:870
  }
}
  34:	f107 070c 	add.w	r7, r7, #12
  38:	46bd      	mov	sp, r7
  3a:	bc80      	pop	{r7}
  3c:	4770      	bx	lr
  3e:	bf00      	nop

Disassembly of section .text.I2C_GetPEC:

00000000 <I2C_GetPEC>:
I2C_GetPEC():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:878
  * @brief  Returns the PEC value for the specified I2C.
  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
  * @retval The PEC value.
  */
uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:882
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Return the selected I2C PEC value */
  return ((I2Cx->SR2) >> 8);
   8:	687b      	ldr	r3, [r7, #4]
   a:	8b1b      	ldrh	r3, [r3, #24]
   c:	b29b      	uxth	r3, r3
   e:	ea4f 2313 	mov.w	r3, r3, lsr #8
  12:	b29b      	uxth	r3, r3
  14:	b2db      	uxtb	r3, r3
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:883
}
  16:	4618      	mov	r0, r3
  18:	f107 070c 	add.w	r7, r7, #12
  1c:	46bd      	mov	sp, r7
  1e:	bc80      	pop	{r7}
  20:	4770      	bx	lr
  22:	bf00      	nop

Disassembly of section .text.I2C_DMACmd:

00000000 <I2C_DMACmd>:
I2C_DMACmd():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:911
  * @param  NewState: new state of the I2C DMA transfer.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	70fb      	strb	r3, [r7, #3]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:915
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   c:	78fb      	ldrb	r3, [r7, #3]
   e:	2b00      	cmp	r3, #0
  10:	d008      	beq.n	24 <I2C_DMACmd+0x24>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:918
  {
    /* Enable the selected I2C DMA requests */
    I2Cx->CR2 |= I2C_CR2_DMAEN;
  12:	687b      	ldr	r3, [r7, #4]
  14:	889b      	ldrh	r3, [r3, #4]
  16:	b29b      	uxth	r3, r3
  18:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
  1c:	b29a      	uxth	r2, r3
  1e:	687b      	ldr	r3, [r7, #4]
  20:	809a      	strh	r2, [r3, #4]
  22:	e007      	b.n	34 <I2C_DMACmd+0x34>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:923
  }
  else
  {
    /* Disable the selected I2C DMA requests */
    I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_DMAEN);
  24:	687b      	ldr	r3, [r7, #4]
  26:	889b      	ldrh	r3, [r3, #4]
  28:	b29b      	uxth	r3, r3
  2a:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
  2e:	b29a      	uxth	r2, r3
  30:	687b      	ldr	r3, [r7, #4]
  32:	809a      	strh	r2, [r3, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:925
  }
}
  34:	f107 070c 	add.w	r7, r7, #12
  38:	46bd      	mov	sp, r7
  3a:	bc80      	pop	{r7}
  3c:	4770      	bx	lr
  3e:	bf00      	nop

Disassembly of section .text.I2C_DMALastTransferCmd:

00000000 <I2C_DMALastTransferCmd>:
I2C_DMALastTransferCmd():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:935
  * @param  NewState: new state of the I2C DMA last transfer.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	70fb      	strb	r3, [r7, #3]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:939
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
   c:	78fb      	ldrb	r3, [r7, #3]
   e:	2b00      	cmp	r3, #0
  10:	d008      	beq.n	24 <I2C_DMALastTransferCmd+0x24>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:942
  {
    /* Next DMA transfer is the last transfer */
    I2Cx->CR2 |= I2C_CR2_LAST;
  12:	687b      	ldr	r3, [r7, #4]
  14:	889b      	ldrh	r3, [r3, #4]
  16:	b29b      	uxth	r3, r3
  18:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
  1c:	b29a      	uxth	r2, r3
  1e:	687b      	ldr	r3, [r7, #4]
  20:	809a      	strh	r2, [r3, #4]
  22:	e007      	b.n	34 <I2C_DMALastTransferCmd+0x34>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:947
  }
  else
  {
    /* Next DMA transfer is not the last transfer */
    I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_LAST);
  24:	687b      	ldr	r3, [r7, #4]
  26:	889b      	ldrh	r3, [r3, #4]
  28:	b29b      	uxth	r3, r3
  2a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  2e:	b29a      	uxth	r2, r3
  30:	687b      	ldr	r3, [r7, #4]
  32:	809a      	strh	r2, [r3, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:949
  }
}
  34:	f107 070c 	add.w	r7, r7, #12
  38:	46bd      	mov	sp, r7
  3a:	bc80      	pop	{r7}
  3c:	4770      	bx	lr
  3e:	bf00      	nop

Disassembly of section .text.I2C_ReadRegister:

00000000 <I2C_ReadRegister>:
I2C_ReadRegister():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1073
  *            @arg I2C_Register_CCR:   CCR register.
  *            @arg I2C_Register_TRISE: TRISE register.
  * @retval The value of the read register.
  */
uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
{
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	460b      	mov	r3, r1
   a:	70fb      	strb	r3, [r7, #3]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1074
  __IO uint32_t tmp = 0;
   c:	f04f 0300 	mov.w	r3, #0
  10:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1080

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_REGISTER(I2C_Register));

  tmp = (uint32_t) I2Cx;
  12:	687b      	ldr	r3, [r7, #4]
  14:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1081
  tmp += I2C_Register;
  16:	78fa      	ldrb	r2, [r7, #3]
  18:	68fb      	ldr	r3, [r7, #12]
  1a:	18d3      	adds	r3, r2, r3
  1c:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1084

  /* Return the selected register value */
  return (*(__IO uint16_t *) tmp);
  1e:	68fb      	ldr	r3, [r7, #12]
  20:	881b      	ldrh	r3, [r3, #0]
  22:	b29b      	uxth	r3, r3
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1085
}
  24:	4618      	mov	r0, r3
  26:	f107 0714 	add.w	r7, r7, #20
  2a:	46bd      	mov	sp, r7
  2c:	bc80      	pop	{r7}
  2e:	4770      	bx	lr

Disassembly of section .text.I2C_ITConfig:

00000000 <I2C_ITConfig>:
I2C_ITConfig():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1100
  * @param  NewState: new state of the specified I2C interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	4613      	mov	r3, r2
   a:	460a      	mov	r2, r1
   c:	807a      	strh	r2, [r7, #2]
   e:	707b      	strb	r3, [r7, #1]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1106
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_I2C_CONFIG_IT(I2C_IT));
  
  if (NewState != DISABLE)
  10:	787b      	ldrb	r3, [r7, #1]
  12:	2b00      	cmp	r3, #0
  14:	d009      	beq.n	2a <I2C_ITConfig+0x2a>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1109
  {
    /* Enable the selected I2C interrupts */
    I2Cx->CR2 |= I2C_IT;
  16:	687b      	ldr	r3, [r7, #4]
  18:	889b      	ldrh	r3, [r3, #4]
  1a:	b29a      	uxth	r2, r3
  1c:	887b      	ldrh	r3, [r7, #2]
  1e:	ea42 0303 	orr.w	r3, r2, r3
  22:	b29a      	uxth	r2, r3
  24:	687b      	ldr	r3, [r7, #4]
  26:	809a      	strh	r2, [r3, #4]
  28:	e00b      	b.n	42 <I2C_ITConfig+0x42>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1114
  }
  else
  {
    /* Disable the selected I2C interrupts */
    I2Cx->CR2 &= (uint16_t)~I2C_IT;
  2a:	687b      	ldr	r3, [r7, #4]
  2c:	889b      	ldrh	r3, [r3, #4]
  2e:	b29a      	uxth	r2, r3
  30:	887b      	ldrh	r3, [r7, #2]
  32:	ea6f 0303 	mvn.w	r3, r3
  36:	b29b      	uxth	r3, r3
  38:	ea02 0303 	and.w	r3, r2, r3
  3c:	b29a      	uxth	r2, r3
  3e:	687b      	ldr	r3, [r7, #4]
  40:	809a      	strh	r2, [r3, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1116
  }
}
  42:	f107 070c 	add.w	r7, r7, #12
  46:	46bd      	mov	sp, r7
  48:	bc80      	pop	{r7}
  4a:	4770      	bx	lr

Disassembly of section .text.I2C_CheckEvent:

00000000 <I2C_CheckEvent>:
I2C_CheckEvent():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1159
  * @retval An ErrorStatus enumeration value:
  *           - SUCCESS: Last event is equal to the I2C_EVENT
  *           - ERROR: Last event is different from the I2C_EVENT
  */
ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
{
   0:	b480      	push	{r7}
   2:	b087      	sub	sp, #28
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	6039      	str	r1, [r7, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1160
  uint32_t lastevent = 0;
   a:	f04f 0300 	mov.w	r3, #0
   e:	613b      	str	r3, [r7, #16]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1161
  uint32_t flag1 = 0, flag2 = 0;
  10:	f04f 0300 	mov.w	r3, #0
  14:	60fb      	str	r3, [r7, #12]
  16:	f04f 0300 	mov.w	r3, #0
  1a:	60bb      	str	r3, [r7, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1162
  ErrorStatus status = ERROR;
  1c:	f04f 0300 	mov.w	r3, #0
  20:	75fb      	strb	r3, [r7, #23]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1169
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_EVENT(I2C_EVENT));

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
  22:	687b      	ldr	r3, [r7, #4]
  24:	8a9b      	ldrh	r3, [r3, #20]
  26:	b29b      	uxth	r3, r3
  28:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1170
  flag2 = I2Cx->SR2;
  2a:	687b      	ldr	r3, [r7, #4]
  2c:	8b1b      	ldrh	r3, [r3, #24]
  2e:	b29b      	uxth	r3, r3
  30:	60bb      	str	r3, [r7, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1171
  flag2 = flag2 << 16;
  32:	68bb      	ldr	r3, [r7, #8]
  34:	ea4f 4303 	mov.w	r3, r3, lsl #16
  38:	60bb      	str	r3, [r7, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1174

  /* Get the last event value from I2C status register */
  lastevent = (flag1 | flag2) & FLAG_MASK;
  3a:	68fa      	ldr	r2, [r7, #12]
  3c:	68bb      	ldr	r3, [r7, #8]
  3e:	ea42 0303 	orr.w	r3, r2, r3
  42:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
  46:	613b      	str	r3, [r7, #16]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1177

  /* Check whether the last event contains the I2C_EVENT */
  if ((lastevent & I2C_EVENT) == I2C_EVENT)
  48:	693a      	ldr	r2, [r7, #16]
  4a:	683b      	ldr	r3, [r7, #0]
  4c:	401a      	ands	r2, r3
  4e:	683b      	ldr	r3, [r7, #0]
  50:	429a      	cmp	r2, r3
  52:	d103      	bne.n	5c <I2C_CheckEvent+0x5c>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1180
  {
    /* SUCCESS: last event is equal to I2C_EVENT */
    status = SUCCESS;
  54:	f04f 0301 	mov.w	r3, #1
  58:	75fb      	strb	r3, [r7, #23]
  5a:	e002      	b.n	62 <I2C_CheckEvent+0x62>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1185
  }
  else
  {
    /* ERROR: last event is different from I2C_EVENT */
    status = ERROR;
  5c:	f04f 0300 	mov.w	r3, #0
  60:	75fb      	strb	r3, [r7, #23]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1188
  }
  /* Return status */
  return status;
  62:	7dfb      	ldrb	r3, [r7, #23]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1189
}
  64:	4618      	mov	r0, r3
  66:	f107 071c 	add.w	r7, r7, #28
  6a:	46bd      	mov	sp, r7
  6c:	bc80      	pop	{r7}
  6e:	4770      	bx	lr

Disassembly of section .text.I2C_GetLastEvent:

00000000 <I2C_GetLastEvent>:
I2C_GetLastEvent():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1207
  *         in stm32f4xx_i2c.h file.
  *    
  * @retval The last event
  */
uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx)
{
   0:	b480      	push	{r7}
   2:	b087      	sub	sp, #28
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1208
  uint32_t lastevent = 0;
   8:	f04f 0300 	mov.w	r3, #0
   c:	617b      	str	r3, [r7, #20]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1209
  uint32_t flag1 = 0, flag2 = 0;
   e:	f04f 0300 	mov.w	r3, #0
  12:	613b      	str	r3, [r7, #16]
  14:	f04f 0300 	mov.w	r3, #0
  18:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1215

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
  1a:	687b      	ldr	r3, [r7, #4]
  1c:	8a9b      	ldrh	r3, [r3, #20]
  1e:	b29b      	uxth	r3, r3
  20:	613b      	str	r3, [r7, #16]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1216
  flag2 = I2Cx->SR2;
  22:	687b      	ldr	r3, [r7, #4]
  24:	8b1b      	ldrh	r3, [r3, #24]
  26:	b29b      	uxth	r3, r3
  28:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1217
  flag2 = flag2 << 16;
  2a:	68fb      	ldr	r3, [r7, #12]
  2c:	ea4f 4303 	mov.w	r3, r3, lsl #16
  30:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1220

  /* Get the last event value from I2C status register */
  lastevent = (flag1 | flag2) & FLAG_MASK;
  32:	693a      	ldr	r2, [r7, #16]
  34:	68fb      	ldr	r3, [r7, #12]
  36:	ea42 0303 	orr.w	r3, r2, r3
  3a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
  3e:	617b      	str	r3, [r7, #20]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1223

  /* Return status */
  return lastevent;
  40:	697b      	ldr	r3, [r7, #20]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1224
}
  42:	4618      	mov	r0, r3
  44:	f107 071c 	add.w	r7, r7, #28
  48:	46bd      	mov	sp, r7
  4a:	bc80      	pop	{r7}
  4c:	4770      	bx	lr
  4e:	bf00      	nop

Disassembly of section .text.I2C_GetFlagStatus:

00000000 <I2C_GetFlagStatus>:
I2C_GetFlagStatus():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1262
  *                                Address matched flag (Slave mode)"ENDAD"
  *            @arg I2C_FLAG_SB: Start bit flag (Master mode)
  * @retval The new state of I2C_FLAG (SET or RESET).
  */
FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
{
   0:	b480      	push	{r7}
   2:	b087      	sub	sp, #28
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	6039      	str	r1, [r7, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1263
  FlagStatus bitstatus = RESET;
   a:	f04f 0300 	mov.w	r3, #0
   e:	75fb      	strb	r3, [r7, #23]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1264
  __IO uint32_t i2creg = 0, i2cxbase = 0;
  10:	f04f 0300 	mov.w	r3, #0
  14:	613b      	str	r3, [r7, #16]
  16:	f04f 0300 	mov.w	r3, #0
  1a:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1271
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_FLAG(I2C_FLAG));

  /* Get the I2Cx peripheral base address */
  i2cxbase = (uint32_t)I2Cx;
  1c:	687b      	ldr	r3, [r7, #4]
  1e:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1274
  
  /* Read flag register index */
  i2creg = I2C_FLAG >> 28;
  20:	683b      	ldr	r3, [r7, #0]
  22:	ea4f 7313 	mov.w	r3, r3, lsr #28
  26:	613b      	str	r3, [r7, #16]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1277
  
  /* Get bit[23:0] of the flag */
  I2C_FLAG &= FLAG_MASK;
  28:	683b      	ldr	r3, [r7, #0]
  2a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
  2e:	603b      	str	r3, [r7, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1279
  
  if(i2creg != 0)
  30:	693b      	ldr	r3, [r7, #16]
  32:	2b00      	cmp	r3, #0
  34:	d004      	beq.n	40 <I2C_GetFlagStatus+0x40>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1282
  {
    /* Get the I2Cx SR1 register address */
    i2cxbase += 0x14;
  36:	68fb      	ldr	r3, [r7, #12]
  38:	f103 0314 	add.w	r3, r3, #20
  3c:	60fb      	str	r3, [r7, #12]
  3e:	e007      	b.n	50 <I2C_GetFlagStatus+0x50>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1287
  }
  else
  {
    /* Flag in I2Cx SR2 Register */
    I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
  40:	683b      	ldr	r3, [r7, #0]
  42:	ea4f 4313 	mov.w	r3, r3, lsr #16
  46:	603b      	str	r3, [r7, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1289
    /* Get the I2Cx SR2 register address */
    i2cxbase += 0x18;
  48:	68fb      	ldr	r3, [r7, #12]
  4a:	f103 0318 	add.w	r3, r3, #24
  4e:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1292
  }
  
  if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
  50:	68fb      	ldr	r3, [r7, #12]
  52:	681a      	ldr	r2, [r3, #0]
  54:	683b      	ldr	r3, [r7, #0]
  56:	ea02 0303 	and.w	r3, r2, r3
  5a:	2b00      	cmp	r3, #0
  5c:	d003      	beq.n	66 <I2C_GetFlagStatus+0x66>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1295
  {
    /* I2C_FLAG is set */
    bitstatus = SET;
  5e:	f04f 0301 	mov.w	r3, #1
  62:	75fb      	strb	r3, [r7, #23]
  64:	e002      	b.n	6c <I2C_GetFlagStatus+0x6c>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1300
  }
  else
  {
    /* I2C_FLAG is reset */
    bitstatus = RESET;
  66:	f04f 0300 	mov.w	r3, #0
  6a:	75fb      	strb	r3, [r7, #23]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1304
  }
  
  /* Return the I2C_FLAG status */
  return  bitstatus;
  6c:	7dfb      	ldrb	r3, [r7, #23]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1305
}
  6e:	4618      	mov	r0, r3
  70:	f107 071c 	add.w	r7, r7, #28
  74:	46bd      	mov	sp, r7
  76:	bc80      	pop	{r7}
  78:	4770      	bx	lr
  7a:	bf00      	nop

Disassembly of section .text.I2C_ClearFlag:

00000000 <I2C_ClearFlag>:
I2C_ClearFlag():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1339
  *          register (I2C_SendData()).
  *  
  * @retval None
  */
void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
{
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	6039      	str	r1, [r7, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1340
  uint32_t flagpos = 0;
   a:	f04f 0300 	mov.w	r3, #0
   e:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1345
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
  /* Get the I2C flag position */
  flagpos = I2C_FLAG & FLAG_MASK;
  10:	683b      	ldr	r3, [r7, #0]
  12:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
  16:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1347
  /* Clear the selected I2C flag */
  I2Cx->SR1 = (uint16_t)~flagpos;
  18:	68fb      	ldr	r3, [r7, #12]
  1a:	b29b      	uxth	r3, r3
  1c:	ea6f 0303 	mvn.w	r3, r3
  20:	b29a      	uxth	r2, r3
  22:	687b      	ldr	r3, [r7, #4]
  24:	829a      	strh	r2, [r3, #20]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1348
}
  26:	f107 0714 	add.w	r7, r7, #20
  2a:	46bd      	mov	sp, r7
  2c:	bc80      	pop	{r7}
  2e:	4770      	bx	lr

Disassembly of section .text.I2C_GetITStatus:

00000000 <I2C_GetITStatus>:
I2C_GetITStatus():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1373
  *                              Address matched flag (Slave mode)"ENDAD"
  *            @arg I2C_IT_SB: Start bit flag (Master mode)
  * @retval The new state of I2C_IT (SET or RESET).
  */
ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
{
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	6039      	str	r1, [r7, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1374
  ITStatus bitstatus = RESET;
   a:	f04f 0300 	mov.w	r3, #0
   e:	73fb      	strb	r3, [r7, #15]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1375
  uint32_t enablestatus = 0;
  10:	f04f 0300 	mov.w	r3, #0
  14:	60bb      	str	r3, [r7, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1382
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_IT(I2C_IT));

  /* Check if the interrupt source is enabled or not */
  enablestatus = (uint32_t)(((I2C_IT & ITEN_MASK) >> 16) & (I2Cx->CR2)) ;
  16:	683b      	ldr	r3, [r7, #0]
  18:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
  1c:	ea4f 4213 	mov.w	r2, r3, lsr #16
  20:	687b      	ldr	r3, [r7, #4]
  22:	889b      	ldrh	r3, [r3, #4]
  24:	b29b      	uxth	r3, r3
  26:	ea02 0303 	and.w	r3, r2, r3
  2a:	60bb      	str	r3, [r7, #8]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1385
  
  /* Get bit[23:0] of the flag */
  I2C_IT &= FLAG_MASK;
  2c:	683b      	ldr	r3, [r7, #0]
  2e:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
  32:	603b      	str	r3, [r7, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1388

  /* Check the status of the specified I2C flag */
  if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
  34:	687b      	ldr	r3, [r7, #4]
  36:	8a9b      	ldrh	r3, [r3, #20]
  38:	b29b      	uxth	r3, r3
  3a:	461a      	mov	r2, r3
  3c:	683b      	ldr	r3, [r7, #0]
  3e:	ea02 0303 	and.w	r3, r2, r3
  42:	2b00      	cmp	r3, #0
  44:	d006      	beq.n	54 <I2C_GetITStatus+0x54>
  46:	68bb      	ldr	r3, [r7, #8]
  48:	2b00      	cmp	r3, #0
  4a:	d003      	beq.n	54 <I2C_GetITStatus+0x54>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1391
  {
    /* I2C_IT is set */
    bitstatus = SET;
  4c:	f04f 0301 	mov.w	r3, #1
  50:	73fb      	strb	r3, [r7, #15]
  52:	e002      	b.n	5a <I2C_GetITStatus+0x5a>
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1396
  }
  else
  {
    /* I2C_IT is reset */
    bitstatus = RESET;
  54:	f04f 0300 	mov.w	r3, #0
  58:	73fb      	strb	r3, [r7, #15]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1399
  }
  /* Return the I2C_IT status */
  return  bitstatus;
  5a:	7bfb      	ldrb	r3, [r7, #15]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1400
}
  5c:	4618      	mov	r0, r3
  5e:	f107 0714 	add.w	r7, r7, #20
  62:	46bd      	mov	sp, r7
  64:	bc80      	pop	{r7}
  66:	4770      	bx	lr

Disassembly of section .text.I2C_ClearITPendingBit:

00000000 <I2C_ClearITPendingBit>:
I2C_ClearITPendingBit():
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1433
  *          I2C_SR1 register (I2C_GetITStatus()) followed by a write operation to 
  *          I2C_DR register (I2C_SendData()).
  * @retval None
  */
void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
{
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	6039      	str	r1, [r7, #0]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1434
  uint32_t flagpos = 0;
   a:	f04f 0300 	mov.w	r3, #0
   e:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1440
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_CLEAR_IT(I2C_IT));

  /* Get the I2C flag position */
  flagpos = I2C_IT & FLAG_MASK;
  10:	683b      	ldr	r3, [r7, #0]
  12:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
  16:	60fb      	str	r3, [r7, #12]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1443

  /* Clear the selected I2C flag */
  I2Cx->SR1 = (uint16_t)~flagpos;
  18:	68fb      	ldr	r3, [r7, #12]
  1a:	b29b      	uxth	r3, r3
  1c:	ea6f 0303 	mvn.w	r3, r3
  20:	b29a      	uxth	r2, r3
  22:	687b      	ldr	r3, [r7, #4]
  24:	829a      	strh	r2, [r3, #20]
C:\Users\gcristian\Desktop\F429\Drivers\src\platform\stm32libs\stm32f4xx\src/stm32f4xx_i2c.c:1444
}
  26:	f107 0714 	add.w	r7, r7, #20
  2a:	46bd      	mov	sp, r7
  2c:	bc80      	pop	{r7}
  2e:	4770      	bx	lr
